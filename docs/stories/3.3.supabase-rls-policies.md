# Story 3.3: Supabase Row Level Security (RLS) Policies

## Status
Draft

## Story
**As a** solo user with sensitive data,
**I want** all database tables protected by Row Level Security policies,
**so that** even if authentication is compromised, data access is restricted to only my user account.

## Acceptance Criteria
1. Every Supabase table has RLS enabled (no exceptions)
2. RLS policies enforce user_id matching: users can only read/write rows where `user_id = auth.uid()`
3. Tables include: `tasks`, `projects`, `phases`, `businesses`, `daily_pages`, `deep_work_sessions`, `health_goals`, `content_items`, `finance_records`, `life_items`, `golf_scores`
4. Sensitive client data tables (financial records, project details) have additional encryption at rest via Supabase encryption features
5. RLS policies are tested with automated script that attempts unauthorized access and verifies denial
6. Service role key (bypasses RLS) is stored securely in GitHub Secrets, never in client code or committed files
7. Anon key (used by frontend) has appropriate permissions via RLS, cannot access other users' data
8. RLS policy audit report generated showing all tables, their policies, and last verification date
9. Database migration scripts include RLS policy creation alongside table creation (never deployed without RLS)

## Tasks / Subtasks
- [ ] Task 1: Audit existing tables for RLS status (AC: 1, 3)
  - [ ] Connect to Supabase SQL Editor
  - [ ] Query system tables: `SELECT * FROM pg_tables WHERE schemaname = 'public'`
  - [ ] Check RLS status for each table: tasks, projects, phases, businesses, daily_pages, deep_work_sessions, health_goals, content_items, finance_records, life_items, golf_scores
  - [ ] Query: `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public'`
  - [ ] Create spreadsheet: Table Name | RLS Enabled | Policy Count | Status
  - [ ] Identify tables missing RLS or policies
  - [ ] Document findings in .ai/rls-audit-report.md
  - [ ] Add timestamp and auditor name to report
- [ ] Task 2: Enable RLS on all tables (AC: 1)
  - [ ] For each table without RLS, run: `ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;`
  - [ ] Execute for: tasks, projects, phases, businesses
  - [ ] Execute for: daily_pages, deep_work_sessions, health_goals
  - [ ] Execute for: content_items, finance_records, life_items, golf_scores
  - [ ] Verify no tables remain with RLS disabled
  - [ ] Test: attempt to query table with anon key before policies → should return empty result
  - [ ] Document all ALTER TABLE commands in migration script
  - [ ] Create .ai/migrations/enable-rls-all-tables.sql
- [ ] Task 3: Create SELECT policies for all tables (AC: 2, 7)
  - [ ] Policy name pattern: `{table_name}_select_policy`
  - [ ] Policy definition: `CREATE POLICY {table_name}_select_policy ON {table_name} FOR SELECT USING (user_id = auth.uid());`
  - [ ] Create SELECT policy for tasks: `FOR SELECT USING (user_id = auth.uid())`
  - [ ] Create SELECT policy for projects: `FOR SELECT USING (user_id = auth.uid())`
  - [ ] Create SELECT policy for phases: `FOR SELECT USING (user_id = auth.uid())`
  - [ ] Create SELECT policy for businesses: `FOR SELECT USING (user_id = auth.uid())`
  - [ ] Create SELECT policies for all remaining tables (daily_pages, deep_work_sessions, health_goals, content_items, finance_records, life_items, golf_scores)
  - [ ] Verify policies created: `SELECT * FROM pg_policies WHERE tablename = 'tasks'`
  - [ ] Test: query table with authenticated user → returns only that user's rows
- [ ] Task 4: Create INSERT policies for all tables (AC: 2)
  - [ ] Policy name pattern: `{table_name}_insert_policy`
  - [ ] Policy definition: `CREATE POLICY {table_name}_insert_policy ON {table_name} FOR INSERT WITH CHECK (user_id = auth.uid());`
  - [ ] Create INSERT policies ensuring user_id matches auth.uid()
  - [ ] Add validation: new rows must have user_id set to current authenticated user
  - [ ] Test: attempt to insert row with different user_id → should fail
  - [ ] Test: insert row with correct user_id → should succeed
  - [ ] Apply to all 11 tables
  - [ ] Document in migration script
- [ ] Task 5: Create UPDATE policies for all tables (AC: 2)
  - [ ] Policy name pattern: `{table_name}_update_policy`
  - [ ] Policy definition: `CREATE POLICY {table_name}_update_policy ON {table_name} FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());`
  - [ ] USING clause: can only update rows you own
  - [ ] WITH CHECK clause: cannot change user_id to someone else
  - [ ] Create UPDATE policies for all 11 tables
  - [ ] Test: attempt to update another user's row → should fail
  - [ ] Test: attempt to change user_id field → should fail
  - [ ] Test: update own row → should succeed
- [ ] Task 6: Create DELETE policies for all tables (AC: 2)
  - [ ] Policy name pattern: `{table_name}_delete_policy`
  - [ ] Policy definition: `CREATE POLICY {table_name}_delete_policy ON {table_name} FOR DELETE USING (user_id = auth.uid());`
  - [ ] Create DELETE policies for all 11 tables
  - [ ] Test: attempt to delete another user's row → should fail
  - [ ] Test: delete own row → should succeed
  - [ ] Consider soft delete policies: UPDATE status = 'deleted' instead of DELETE
  - [ ] Document deletion behavior in RLS audit report
- [ ] Task 7: Implement encryption for sensitive data tables (AC: 4)
  - [ ] Identify sensitive fields: finance_records (bank account numbers, balances), businesses (client company names), projects (contract values)
  - [ ] Verify Supabase encryption at rest is enabled (enabled by default)
  - [ ] Consider additional column-level encryption using pgcrypto for fields like account numbers
  - [ ] Example: `CREATE EXTENSION IF NOT EXISTS pgcrypto;`
  - [ ] Encrypt field: `UPDATE finance_records SET account_number = pgp_sym_encrypt(account_number, 'encryption_key');`
  - [ ] Decrypt in queries: `SELECT pgp_sym_decrypt(account_number::bytea, 'encryption_key') FROM finance_records;`
  - [ ] Store encryption key in GitHub Secrets (not in code)
  - [ ] Document encryption approach: at-rest (Supabase default) vs. column-level (pgcrypto)
  - [ ] For MVP: rely on Supabase's default encryption at rest
  - [ ] Plan for future: implement pgcrypto for PII fields if storing actual client financial data
- [ ] Task 8: Create RLS policy test script (AC: 5)
  - [ ] Create .ai/tests/test-rls-policies.sql script
  - [ ] Test 1: Create two test users in Supabase Auth
  - [ ] Test 2: Insert tasks for User A
  - [ ] Test 3: Authenticate as User B, attempt to SELECT User A's tasks → expect empty result
  - [ ] Test 4: Authenticate as User B, attempt to UPDATE User A's task → expect error
  - [ ] Test 5: Authenticate as User B, attempt to DELETE User A's task → expect error
  - [ ] Test 6: Authenticate as User B, attempt to INSERT task with User A's user_id → expect error
  - [ ] Test 7: Authenticate as User A, SELECT own tasks → expect results
  - [ ] Test 8: Authenticate as User A, UPDATE own task → expect success
  - [ ] Automate tests using Supabase client library in Node.js script
  - [ ] Document test results in RLS audit report
- [ ] Task 9: Secure service role key storage (AC: 6)
  - [ ] Verify service role key never appears in src/ directory
  - [ ] Search codebase: `grep -r "SERVICE_ROLE" src/` → should return nothing
  - [ ] Add service role key to GitHub Secrets: Settings → Secrets → Actions → New secret
  - [ ] Secret name: SUPABASE_SERVICE_ROLE_KEY
  - [ ] Document: service role key bypasses RLS, use only in secure backend scripts
  - [ ] Update GitHub Actions workflow if service role key needed for migrations
  - [ ] Never use service role key in client-side code (React app)
  - [ ] Add warning comment in .env.example: "Do not use service role key in client - it bypasses RLS"
  - [ ] Add to security checklist: verify service role key not in client code
- [ ] Task 10: Generate RLS policy audit report (AC: 8)
  - [ ] Create .ai/rls-audit-report.md template
  - [ ] Header: Audit Date, Auditor, Supabase Project ID
  - [ ] Table: Table Name | RLS Enabled | SELECT Policy | INSERT Policy | UPDATE Policy | DELETE Policy | Status
  - [ ] Query all policies: `SELECT * FROM pg_policies ORDER BY tablename, policyname;`
  - [ ] For each table, document: policy names, policy definitions, policy type (PERMISSIVE vs RESTRICTIVE)
  - [ ] Add section: Test Results (from Task 8)
  - [ ] Add section: Findings (any tables without complete policies)
  - [ ] Add section: Recommendations (additional security measures)
  - [ ] Schedule: regenerate report monthly or after schema changes
  - [ ] Include in pre-deployment security checklist
- [ ] Task 11: Create RLS-enabled migration script template (AC: 9)
  - [ ] Create .ai/templates/rls-table-migration.sql
  - [ ] Template includes: CREATE TABLE, ALTER TABLE ADD user_id, ENABLE RLS, CREATE all 4 policies
  - [ ] Example template:
    ```sql
    -- Create table
    CREATE TABLE new_table (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      user_id UUID REFERENCES auth.users(id) NOT NULL,
      created_at TIMESTAMP DEFAULT NOW(),
      -- other fields
    );

    -- Enable RLS
    ALTER TABLE new_table ENABLE ROW LEVEL SECURITY;

    -- Create policies
    CREATE POLICY new_table_select_policy ON new_table FOR SELECT USING (user_id = auth.uid());
    CREATE POLICY new_table_insert_policy ON new_table FOR INSERT WITH CHECK (user_id = auth.uid());
    CREATE POLICY new_table_update_policy ON new_table FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());
    CREATE POLICY new_table_delete_policy ON new_table FOR DELETE USING (user_id = auth.uid());
    ```
  - [ ] Document: always use this template for new tables
  - [ ] Add to developer guide: never create table without RLS
  - [ ] Include in Story 3.1 security checklist: verify new tables have RLS

## Dev Notes

### Previous Story Insights
**From Story 3.1:** [Source: docs/stories/3.1.pre-deployment-security-checklist.md]
- Security checklist includes RLS policy verification section
- verify-rls.sql script queries system tables for RLS status
- Security check runs before deployment

**From Story 3.2:** [Source: docs/stories/3.2.github-secret-scanning-protection.md]
- Service role key stored in GitHub Secrets only
- Anon key used in client code (src/lib/supabase.ts)
- Environment variables: VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY

**From Story 1.1:** [Source: docs/stories/1.1.tasks-hub-page-structure.md]
- Database tables created: tasks, projects, phases, businesses, life_areas
- All tables include user_id field for RLS filtering
- Foreign key relationships established
- RLS policies mentioned but may not be fully implemented

**Key Security Context:**
- RLS is the PRIMARY security mechanism protecting data
- Even if authentication is compromised, RLS prevents data access
- Service role key bypasses RLS - must be tightly controlled
- Anon key respects RLS - safe for client use
- Solo user dashboard but still need RLS (protects against bugs, future multi-user scenarios)

### Architecture Context

**Tech Stack:** [Source: docs/prd/technical-assumptions.md]
- Backend: Supabase PostgreSQL database
- Authentication: Supabase Auth (provides auth.uid() function)
- Client: React app using Supabase JS client with anon key

**Supabase RLS Architecture:**
```
Client (React App)
  ↓ uses anon key
Supabase API Layer
  ↓ enforces RLS
PostgreSQL Database (with RLS enabled)
  ↓ checks auth.uid() in policies
Returns only rows matching user_id = auth.uid()
```

**RLS Policy Types:**
- **PERMISSIVE** (default): Multiple policies OR'd together (if any allow, operation proceeds)
- **RESTRICTIVE**: Multiple policies AND'd together (all must allow)
- For solo user: PERMISSIVE policies sufficient
- Policy applies to: SELECT, INSERT, UPDATE, DELETE (create separate policy for each)

**RLS Policy Components:**
- **USING**: Condition to determine which rows are visible/modifiable
- **WITH CHECK**: Condition to validate new/updated rows (for INSERT/UPDATE)

**Database Schema Requirements:** [Source: docs/stories/1.1.tasks-hub-page-structure.md]
All tables must have:
- `user_id UUID REFERENCES auth.users(id) NOT NULL` column
- `user_id` indexed for query performance
- RLS enabled: `ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;`
- Four policies: SELECT, INSERT, UPDATE, DELETE

**Complete RLS Policy Pattern for Each Table:**
```sql
-- Example for tasks table

-- 1. Ensure user_id column exists (should be in CREATE TABLE)
-- CREATE TABLE tasks (
--   id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
--   user_id UUID REFERENCES auth.users(id) NOT NULL,
--   ...other fields
-- );

-- 2. Enable RLS
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

-- 3. SELECT policy: users can only see their own rows
CREATE POLICY tasks_select_policy ON tasks
  FOR SELECT
  USING (user_id = auth.uid());

-- 4. INSERT policy: users can only insert rows for themselves
CREATE POLICY tasks_insert_policy ON tasks
  FOR INSERT
  WITH CHECK (user_id = auth.uid());

-- 5. UPDATE policy: users can only update their own rows, cannot change user_id
CREATE POLICY tasks_update_policy ON tasks
  FOR UPDATE
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- 6. DELETE policy: users can only delete their own rows
CREATE POLICY tasks_delete_policy ON tasks
  FOR DELETE
  USING (user_id = auth.uid());
```

**RLS Verification Query:**
```sql
-- Check which tables have RLS enabled
SELECT
  schemaname,
  tablename,
  rowsecurity as rls_enabled
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY tablename;

-- Check existing policies for a specific table
SELECT
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies
WHERE tablename = 'tasks'
ORDER BY cmd;

-- Expected output for tasks table:
-- | policyname            | cmd    | qual                  | with_check            |
-- |-----------------------|--------|------------------------|------------------------|
-- | tasks_select_policy   | SELECT | user_id = auth.uid()  | NULL                  |
-- | tasks_insert_policy   | INSERT | NULL                  | user_id = auth.uid()  |
-- | tasks_update_policy   | UPDATE | user_id = auth.uid()  | user_id = auth.uid()  |
-- | tasks_delete_policy   | DELETE | user_id = auth.uid()  | NULL                  |
```

**Testing RLS with Supabase Client:**
```typescript
// Test script: .ai/tests/test-rls.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.VITE_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

// Create two test users
const testUser1 = { email: 'test1@example.com', password: 'test123456' };
const testUser2 = { email: 'test2@example.com', password: 'test123456' };

async function testRLS() {
  // Client with service role key (bypasses RLS - for setup only)
  const adminClient = createClient(supabaseUrl, supabaseServiceKey);

  // Create test data for User 1
  const { data: { user: user1 } } = await adminClient.auth.signUp(testUser1);
  await adminClient.from('tasks').insert({
    user_id: user1!.id,
    title: 'User 1 Task',
    status: 'active',
  });

  // Create test data for User 2
  const { data: { user: user2 } } = await adminClient.auth.signUp(testUser2);

  // Sign in as User 2
  const client2 = createClient(supabaseUrl, process.env.VITE_SUPABASE_ANON_KEY!);
  await client2.auth.signInWithPassword(testUser2);

  // Attempt to access User 1's tasks
  const { data, error } = await client2.from('tasks').select('*');

  // Expected: data is empty array (User 2 cannot see User 1's tasks)
  console.assert(data?.length === 0, 'RLS failed: User 2 can see User 1\'s tasks');

  // Cleanup
  await adminClient.auth.admin.deleteUser(user1!.id);
  await adminClient.auth.admin.deleteUser(user2!.id);

  console.log('✅ RLS test passed');
}

testRLS();
```

**Encryption at Rest (Supabase):**
- Supabase enables encryption at rest by default (AES-256)
- All data encrypted on disk automatically
- No additional configuration needed for basic encryption
- For column-level encryption (PII/financial data), use pgcrypto extension

**Service Role Key Usage Rules:**
- **NEVER** use in client-side code (React app)
- Store only in GitHub Secrets for CI/CD
- Use only in: database migrations, admin scripts, backend functions
- Bypasses RLS - provides full database access
- Rotate if ever exposed

**Anon Key Usage:**
- Safe to use in client-side code
- Exposed to public via browser
- Protected by RLS policies
- Cannot access other users' data
- Cannot perform admin operations

**File Locations:**
- Create: .ai/rls-audit-report.md (audit documentation)
- Create: .ai/migrations/enable-rls-all-tables.sql (migration script)
- Create: .ai/templates/rls-table-migration.sql (template for new tables)
- Create: .ai/tests/test-rls-policies.sql (SQL test script)
- Create: .ai/tests/test-rls.ts (TypeScript test script)
- Update: .ai/security-checklist.md (add RLS verification steps)
- Reference: docs/stories/1.1.tasks-hub-page-structure.md (original schema)

### Testing

**Testing Requirements:** [Source: docs/prd/technical-assumptions.md]
Manual testing with systematic verification (no automated test suite per PRD)

**RLS Policy Validation Workflow:**

1. **RLS Status Verification:**
   ```sql
   -- Run in Supabase SQL Editor
   SELECT tablename, rowsecurity
   FROM pg_tables
   WHERE schemaname = 'public'
     AND tablename IN ('tasks', 'projects', 'phases', 'businesses',
                       'daily_pages', 'deep_work_sessions', 'health_goals',
                       'content_items', 'finance_records', 'life_items', 'golf_scores')
   ORDER BY tablename;

   -- Expected: All tables show rowsecurity = true
   ```

2. **Policy Existence Verification:**
   ```sql
   -- Check each table has 4 policies (SELECT, INSERT, UPDATE, DELETE)
   SELECT tablename, COUNT(*) as policy_count
   FROM pg_policies
   WHERE tablename IN ('tasks', 'projects', 'phases', 'businesses',
                       'daily_pages', 'deep_work_sessions', 'health_goals',
                       'content_items', 'finance_records', 'life_items', 'golf_scores')
   GROUP BY tablename
   ORDER BY tablename;

   -- Expected: Each table shows policy_count = 4
   ```

3. **Policy Definition Verification:**
   ```sql
   -- Verify policies use auth.uid() correctly
   SELECT tablename, policyname, cmd, qual, with_check
   FROM pg_policies
   WHERE tablename = 'tasks'
   ORDER BY cmd;

   -- Expected: All policies reference auth.uid()
   ```

4. **Functional RLS Testing (Manual):**
   - Sign in to dashboard with your account
   - Create test task: "Test RLS Task"
   - Note task ID and user_id
   - Open Supabase SQL Editor
   - Run query with different user_id:
     ```sql
     -- This should return empty (RLS blocks access)
     SELECT * FROM tasks WHERE id = 'test-task-id' AND user_id != auth.uid();
     ```
   - Attempt to update task with SQL:
     ```sql
     -- This should fail (RLS blocks update)
     UPDATE tasks SET title = 'Hacked' WHERE user_id != auth.uid();
     ```

5. **Cross-User Access Testing:**
   - Create second test user in Supabase Auth
   - Use Supabase client to sign in as User 1, create task
   - Sign in as User 2, attempt to query all tasks
   - Verify User 2 cannot see User 1's task
   - Attempt to update User 1's task as User 2 → verify error
   - Attempt to delete User 1's task as User 2 → verify error

6. **Service Role Key Isolation:**
   ```bash
   # Verify service role key not in client code
   grep -r "SERVICE_ROLE" src/
   # Expected: No results

   # Verify service role key not in repository history
   git log -p | grep "SERVICE_ROLE"
   # Expected: No results

   # Verify service role key in GitHub Secrets
   # Manual: Check GitHub → Settings → Secrets → Actions → SUPABASE_SERVICE_ROLE_KEY exists
   ```

7. **Anon Key RLS Compliance:**
   - Open browser DevTools → Application → Local Storage
   - Copy anon key from localStorage or inspect supabase.ts
   - Attempt direct API call with anon key using curl:
     ```bash
     curl 'https://YOUR-PROJECT.supabase.co/rest/v1/tasks' \
       -H "apikey: YOUR-ANON-KEY" \
       -H "Authorization: Bearer ANOTHER-USERS-TOKEN"
     ```
   - Expected: Returns only authenticated user's tasks, not other users'

8. **Migration Script Verification:**
   - Review .ai/migrations/enable-rls-all-tables.sql
   - Verify includes ALTER TABLE ... ENABLE RLS for all 11 tables
   - Verify includes CREATE POLICY for all 4 operations per table
   - Test migration on development database
   - Verify all policies created successfully
   - Run RLS verification queries to confirm

9. **Audit Report Generation:**
   - Run RLS status queries from tests 1-3 above
   - Document results in .ai/rls-audit-report.md
   - Include: audit date, auditor name, Supabase project
   - List each table with RLS status and policy count
   - Note any findings or missing policies
   - Sign off: "All tables have RLS enabled with complete policies"

10. **Template Validation:**
    - Create new test table using .ai/templates/rls-table-migration.sql
    - Execute CREATE TABLE statement
    - Execute ALTER TABLE ENABLE RLS
    - Execute all 4 CREATE POLICY statements
    - Verify RLS works on new table with same tests as above
    - Drop test table after validation

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
