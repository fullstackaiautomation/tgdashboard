# Story 3.5: Authentication & Session Security

## Status
Draft

## Story
**As the** sole user of this dashboard,
**I want** secure authentication that prevents unauthorized access,
**so that** my business data and client information remain private even if my device is compromised.

## Acceptance Criteria
1. Supabase authentication configured with email + password (minimum 12 characters, complexity requirements)
2. Session timeout after 24 hours of inactivity, requires re-authentication
3. "Remember me" functionality uses secure, httpOnly cookies (not localStorage for sensitive tokens)
4. Login attempts are rate-limited: max 5 failed attempts per 15 minutes, then temporary account lock with email notification
5. Two-factor authentication (2FA) available as optional enhancement using Supabase Auth 2FA features
6. Password reset flow includes email verification and link expiration (15 minutes)
7. Active session monitoring: dashboard displays "Last login: [timestamp]" and allows viewing active sessions
8. Logout functionality clears all local storage, session storage, and cookies completely
9. Authentication errors display user-friendly messages without revealing system details (no "user not found" vs "wrong password" distinction)

## Tasks / Subtasks
- [ ] Task 1: Configure Supabase Auth password requirements (AC: 1)
  - [ ] Navigate to Supabase Dashboard → Authentication → Settings → Password
  - [ ] Set minimum password length: 12 characters
  - [ ] Enable password complexity requirements if available
  - [ ] Alternative: implement client-side validation for password complexity
  - [ ] Regex pattern: ^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{12,}$
  - [ ] Requirements: 1 uppercase, 1 lowercase, 1 number, 1 special character, min 12 chars
  - [ ] Display password strength indicator during signup/password change
  - [ ] Show requirements checklist: "✓ 12+ characters", "✓ 1 uppercase", etc.
  - [ ] Test: attempt weak password → verify rejected with helpful message
- [ ] Task 2: Implement session timeout after 24 hours inactivity (AC: 2)
  - [ ] Configure Supabase session expiry in Dashboard → Authentication → Settings
  - [ ] Set JWT expiry: 24 hours (86400 seconds)
  - [ ] Set refresh token expiry: 7 days (allows "remember me" for week)
  - [ ] Implement activity tracking: update "last activity" timestamp on user interactions
  - [ ] Create src/hooks/useSessionTimeout.ts hook
  - [ ] Monitor user activity: mouse movement, clicks, keyboard input
  - [ ] If no activity for 24 hours → call supabase.auth.signOut()
  - [ ] Display warning modal 5 minutes before timeout: "Session expiring soon. Continue?"
  - [ ] On timeout: redirect to login page with message: "Session expired due to inactivity"
- [ ] Task 3: Implement secure "Remember Me" with httpOnly cookies (AC: 3)
  - [ ] Supabase Auth stores tokens in localStorage by default (not ideal for security)
  - [ ] Alternative: use httpOnly cookies via Supabase server-side integration
  - [ ] For client-only app: rely on Supabase's refresh token mechanism
  - [ ] Configure Supabase Auth to use cookies instead of localStorage (if hosting allows)
  - [ ] Verify refresh tokens stored securely (httpOnly, Secure, SameSite flags)
  - [ ] "Remember Me" checkbox on login: extends refresh token expiry to 30 days
  - [ ] Without "Remember Me": refresh token expires in 24 hours
  - [ ] Document limitation: client-side React app uses localStorage by default (Supabase limitation)
  - [ ] Consider: add server-side proxy for enhanced security (future enhancement)
- [ ] Task 4: Implement rate limiting for login attempts (AC: 4)
  - [ ] Create login_attempts table: id, email, attempt_timestamp, ip_address, success BOOLEAN
  - [ ] Track failed login attempts per email address
  - [ ] Query: count failed attempts in last 15 minutes
  - [ ] If count >= 5 → block login, display: "Too many failed attempts. Try again in 15 minutes."
  - [ ] Create src/utils/rateLimiting.ts utility
  - [ ] Function: checkRateLimit(email: string) → returns { allowed: boolean, remainingAttempts: number }
  - [ ] On failed login: insert record into login_attempts table
  - [ ] On successful login: clear failed attempts for that email
  - [ ] Send email notification on account lock: "Your account was temporarily locked due to failed login attempts"
  - [ ] Alternative: use Supabase Edge Functions for server-side rate limiting (more secure)
- [ ] Task 5: Configure Two-Factor Authentication (2FA) (AC: 5)
  - [ ] Supabase supports 2FA via TOTP (Time-based One-Time Password)
  - [ ] Navigate to Supabase Dashboard → Authentication → Settings → Enable 2FA
  - [ ] Add 2FA enrollment UI in dashboard: Settings → Security → Enable 2FA
  - [ ] Use Supabase client: `supabase.auth.mfa.enroll({ factorType: 'totp' })`
  - [ ] Display QR code for user to scan with authenticator app (Google Authenticator, Authy)
  - [ ] Store backup codes securely: display once, user must save
  - [ ] Verify enrollment: user enters 6-digit code from authenticator app
  - [ ] On login with 2FA enabled: prompt for 6-digit code after password
  - [ ] Add "Disable 2FA" option in settings (requires password confirmation)
  - [ ] For MVP: 2FA is optional (can enable later when needed)
- [ ] Task 6: Implement secure password reset flow (AC: 6)
  - [ ] Use Supabase Auth password reset: `supabase.auth.resetPasswordForEmail(email)`
  - [ ] On forgot password page: user enters email → Supabase sends reset link
  - [ ] Email contains magic link with token, expires in 15 minutes
  - [ ] Configure email template in Supabase Dashboard → Authentication → Email Templates
  - [ ] Customize reset email: "Click here to reset your password. Link expires in 15 minutes."
  - [ ] On reset link click: redirect to password reset page with token
  - [ ] Password reset page: user enters new password (validates complexity)
  - [ ] Submit: call `supabase.auth.updateUser({ password: newPassword })`
  - [ ] On success: display "Password updated successfully. Please log in."
  - [ ] Log password reset event to audit_logs table
- [ ] Task 7: Build active session monitoring UI (AC: 7)
  - [ ] Create sessions table: id, user_id, login_timestamp, last_activity, ip_address, user_agent, device_info
  - [ ] On login: insert record into sessions table
  - [ ] Update last_activity on each user interaction (debounced to avoid excessive writes)
  - [ ] Create src/components/security/ActiveSessions.tsx component
  - [ ] Display current session: "Current session: logged in from [device] on [date]"
  - [ ] Display "Last login: [timestamp]" in dashboard header or settings page
  - [ ] Show list of active sessions: device, location, last activity
  - [ ] Add "Revoke" button to terminate specific session
  - [ ] Add "Revoke All Other Sessions" button for security
  - [ ] On revoke: delete session from table, invalidate refresh token
  - [ ] Alert if login from new device: "New login detected from [device] at [location]"
- [ ] Task 8: Implement comprehensive logout functionality (AC: 8)
  - [ ] Create src/utils/logout.ts utility
  - [ ] Step 1: Call supabase.auth.signOut() to invalidate tokens
  - [ ] Step 2: Clear localStorage: localStorage.clear()
  - [ ] Step 3: Clear sessionStorage: sessionStorage.clear()
  - [ ] Step 4: Clear React Query cache: queryClient.clear()
  - [ ] Step 5: Clear any custom cookies (if used)
  - [ ] Step 6: Delete session record from sessions table
  - [ ] Step 7: Redirect to login page
  - [ ] Add logout button in sidebar and settings page
  - [ ] Add confirmation: "Are you sure you want to log out?"
  - [ ] Test: logout → verify cannot access dashboard without re-login
  - [ ] Test: verify back button doesn't show cached sensitive data
- [ ] Task 9: Implement secure authentication error handling (AC: 9)
  - [ ] Generic error messages: "Invalid email or password" (don't reveal which)
  - [ ] Never display: "User not found" or "Incorrect password" (security risk)
  - [ ] Supabase errors mapped to user-friendly messages
  - [ ] Error: "Invalid login credentials" → Display: "Invalid email or password"
  - [ ] Error: "Email not confirmed" → Display: "Please verify your email address"
  - [ ] Error: "User banned" → Display: "Account access suspended. Contact support."
  - [ ] Create src/utils/authErrors.ts with error mapping
  - [ ] Log actual errors to console in development only (not production)
  - [ ] Add error toast notifications with user-friendly messages
  - [ ] Don't expose stack traces or technical details to users
- [ ] Task 10: Create authentication security dashboard section (AC: 7)
  - [ ] Add "Security" section to Settings page
  - [ ] Display: Last login timestamp and device
  - [ ] Display: Active sessions list with device info
  - [ ] Display: Recent login attempts (successful and failed)
  - [ ] Display: Password last changed date with "Change Password" button
  - [ ] Display: 2FA status with "Enable 2FA" or "Disable 2FA" button
  - [ ] Display: Security events log: recent password changes, 2FA changes, session revocations
  - [ ] Add "Download Security Report" button: exports audit log as PDF
  - [ ] Visual indicators: green checkmark for 2FA enabled, red warning for weak password

## Dev Notes

### Previous Story Insights
**From Story 3.1:** [Source: docs/stories/3.1.pre-deployment-security-checklist.md]
- Security checklist includes authentication verification
- Pre-deployment security checks enforced

**From Story 3.2:** [Source: docs/stories/3.2.github-secret-scanning-protection.md]
- Environment variables secured: VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY
- No credentials in codebase

**From Story 3.3:** [Source: docs/stories/3.3.supabase-rls-policies.md]
- RLS policies use auth.uid() to enforce user isolation
- Authentication is foundation for all security (RLS depends on it)

**From Story 3.4:** [Source: docs/stories/3.4.client-data-encryption-protocols.md]
- Audit logging tracks sensitive data access
- audit_logs table includes user_id from auth

**From Story 1.1:** [Source: docs/stories/1.1.tasks-hub-page-structure.md]
- Supabase Auth already configured in src/lib/supabase.ts
- User authentication likely already functional (but needs hardening)

**Key Security Context:**
- Solo user dashboard but treating security as production-grade
- Device could be compromised → need session timeouts and logout
- Handling sensitive client financial data → strong authentication critical
- 24-hour session timeout per PRD requirement
- 2FA is optional enhancement (not mandatory for solo user)
- Rate limiting prevents brute force attacks even for solo user

### Architecture Context

**Tech Stack:** [Source: docs/prd/technical-assumptions.md]
- Authentication: Supabase Auth (email/password, 2FA, password reset)
- Frontend: React + TypeScript
- State: React Query for auth state management
- Storage: localStorage (Supabase default) or httpOnly cookies (if server-side)

**Supabase Auth Flow:**
```
User enters credentials
  ↓
supabase.auth.signInWithPassword({ email, password })
  ↓
Supabase validates credentials
  ↓
Returns { session: { access_token, refresh_token, user } }
  ↓
Access token stored in localStorage (default)
  ↓
Access token sent with every API request (Authorization header)
  ↓
Supabase validates token, provides auth.uid() for RLS
```

**Session Management Pattern:**
```typescript
// src/hooks/useSessionTimeout.ts
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';

const INACTIVITY_TIMEOUT = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
const WARNING_BEFORE_TIMEOUT = 5 * 60 * 1000; // 5 minutes

export function useSessionTimeout() {
  const [lastActivity, setLastActivity] = useState(Date.now());
  const [showWarning, setShowWarning] = useState(false);

  useEffect(() => {
    // Track user activity
    const updateActivity = () => setLastActivity(Date.now());

    window.addEventListener('mousemove', updateActivity);
    window.addEventListener('keydown', updateActivity);
    window.addEventListener('click', updateActivity);

    // Check for inactivity
    const interval = setInterval(() => {
      const inactiveTime = Date.now() - lastActivity;

      if (inactiveTime >= INACTIVITY_TIMEOUT) {
        // Session expired - logout
        supabase.auth.signOut();
        window.location.href = '/login?reason=timeout';
      } else if (inactiveTime >= INACTIVITY_TIMEOUT - WARNING_BEFORE_TIMEOUT) {
        // Show warning
        setShowWarning(true);
      }
    }, 60000); // Check every minute

    return () => {
      window.removeEventListener('mousemove', updateActivity);
      window.removeEventListener('keydown', updateActivity);
      window.removeEventListener('click', updateActivity);
      clearInterval(interval);
    };
  }, [lastActivity]);

  const extendSession = () => {
    setLastActivity(Date.now());
    setShowWarning(false);
  };

  return { showWarning, extendSession };
}
```

**Rate Limiting Implementation:**
```typescript
// src/utils/rateLimiting.ts
import { supabase } from '@/lib/supabase';

const MAX_ATTEMPTS = 5;
const LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes

export async function checkRateLimit(email: string): Promise<{
  allowed: boolean;
  remainingAttempts: number;
  lockedUntil?: Date;
}> {
  const now = new Date();
  const fifteenMinutesAgo = new Date(now.getTime() - LOCKOUT_DURATION);

  // Count failed attempts in last 15 minutes
  const { data: attempts, error } = await supabase
    .from('login_attempts')
    .select('*')
    .eq('email', email)
    .eq('success', false)
    .gte('attempt_timestamp', fifteenMinutesAgo.toISOString())
    .order('attempt_timestamp', { ascending: false });

  if (error) {
    console.error('Error checking rate limit:', error);
    return { allowed: true, remainingAttempts: MAX_ATTEMPTS };
  }

  const failedAttempts = attempts?.length || 0;

  if (failedAttempts >= MAX_ATTEMPTS) {
    const oldestAttempt = new Date(attempts![0].attempt_timestamp);
    const lockedUntil = new Date(oldestAttempt.getTime() + LOCKOUT_DURATION);

    return {
      allowed: false,
      remainingAttempts: 0,
      lockedUntil,
    };
  }

  return {
    allowed: true,
    remainingAttempts: MAX_ATTEMPTS - failedAttempts,
  };
}

export async function logLoginAttempt(
  email: string,
  success: boolean,
  ipAddress?: string
): Promise<void> {
  await supabase.from('login_attempts').insert({
    email,
    success,
    attempt_timestamp: new Date().toISOString(),
    ip_address: ipAddress,
  });

  // Clean up old attempts (older than 24 hours)
  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
  await supabase
    .from('login_attempts')
    .delete()
    .lt('attempt_timestamp', oneDayAgo.toISOString());
}
```

**Password Validation Pattern:**
```typescript
// src/utils/passwordValidation.ts
interface PasswordStrength {
  score: number; // 0-4
  requirements: {
    minLength: boolean;
    hasUppercase: boolean;
    hasLowercase: boolean;
    hasNumber: boolean;
    hasSpecialChar: boolean;
  };
  feedback: string;
}

export function validatePassword(password: string): PasswordStrength {
  const requirements = {
    minLength: password.length >= 12,
    hasUppercase: /[A-Z]/.test(password),
    hasLowercase: /[a-z]/.test(password),
    hasNumber: /\d/.test(password),
    hasSpecialChar: /[@$!%*?&]/.test(password),
  };

  const score = Object.values(requirements).filter(Boolean).length;

  let feedback = '';
  if (score < 3) feedback = 'Weak password. Add uppercase, numbers, and special characters.';
  else if (score < 5) feedback = 'Moderate password. Meet all requirements for best security.';
  else feedback = 'Strong password!';

  return { score, requirements, feedback };
}

export function isPasswordValid(password: string): boolean {
  const { requirements } = validatePassword(password);
  return Object.values(requirements).every(Boolean);
}
```

**2FA Enrollment Flow:**
```typescript
// src/components/security/TwoFactorSetup.tsx
import { useState } from 'react';
import { supabase } from '@/lib/supabase';
import QRCode from 'qrcode';

export function TwoFactorSetup() {
  const [qrCode, setQrCode] = useState<string>('');
  const [backupCodes, setBackupCodes] = useState<string[]>([]);
  const [verificationCode, setVerificationCode] = useState('');

  const enrollMFA = async () => {
    // Step 1: Enroll MFA factor
    const { data, error } = await supabase.auth.mfa.enroll({
      factorType: 'totp',
    });

    if (error) {
      console.error('MFA enrollment failed:', error);
      return;
    }

    // Step 2: Generate QR code from TOTP URI
    const qrCodeUrl = await QRCode.toDataURL(data.totp.qr_code);
    setQrCode(qrCodeUrl);

    // Step 3: Display secret (for manual entry in authenticator app)
    console.log('TOTP Secret:', data.totp.secret);

    // Step 4: Generate backup codes (implement custom logic)
    const codes = generateBackupCodes(8);
    setBackupCodes(codes);
  };

  const verifyMFA = async (factorId: string) => {
    // User enters 6-digit code from authenticator app
    const { error } = await supabase.auth.mfa.verify({
      factorId,
      code: verificationCode,
    });

    if (error) {
      alert('Invalid verification code. Please try again.');
      return;
    }

    alert('2FA enabled successfully!');
  };

  return (
    <div>
      <h2>Enable Two-Factor Authentication</h2>
      <button onClick={enrollMFA}>Start Setup</button>

      {qrCode && (
        <div>
          <img src={qrCode} alt="QR Code" />
          <p>Scan this QR code with your authenticator app</p>

          <input
            type="text"
            placeholder="Enter 6-digit code"
            value={verificationCode}
            onChange={(e) => setVerificationCode(e.target.value)}
          />
          <button onClick={() => verifyMFA('factor-id')}>Verify</button>

          <div>
            <h3>Backup Codes (save these securely)</h3>
            <ul>
              {backupCodes.map((code, i) => (
                <li key={i}>{code}</li>
              ))}
            </ul>
          </div>
        </div>
      )}
    </div>
  );
}

function generateBackupCodes(count: number): string[] {
  return Array.from({ length: count }, () =>
    Math.random().toString(36).substring(2, 10).toUpperCase()
  );
}
```

**Database Schema Additions:**
```sql
-- Login attempts tracking
CREATE TABLE login_attempts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT NOT NULL,
  attempt_timestamp TIMESTAMP DEFAULT NOW(),
  success BOOLEAN NOT NULL,
  ip_address TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_login_attempts_email_time ON login_attempts(email, attempt_timestamp DESC);

-- Active sessions tracking
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  login_timestamp TIMESTAMP DEFAULT NOW(),
  last_activity TIMESTAMP DEFAULT NOW(),
  ip_address TEXT,
  user_agent TEXT,
  device_info JSONB,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sessions_user_active ON sessions(user_id, is_active);

-- RLS policies
ALTER TABLE login_attempts ENABLE ROW LEVEL SECURITY;
-- No RLS needed - login attempts tracked before authentication

ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
CREATE POLICY sessions_select_policy ON sessions FOR SELECT USING (user_id = auth.uid());
CREATE POLICY sessions_insert_policy ON sessions FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY sessions_update_policy ON sessions FOR UPDATE USING (user_id = auth.uid());
CREATE POLICY sessions_delete_policy ON sessions FOR DELETE USING (user_id = auth.uid());
```

**Secure Logout Utility:**
```typescript
// src/utils/logout.ts
import { supabase } from '@/lib/supabase';
import { queryClient } from '@/lib/queryClient';

export async function secureLogout(): Promise<void> {
  try {
    // 1. Get current session ID if tracked
    const { data: { session } } = await supabase.auth.getSession();
    const sessionId = session?.user?.id;

    // 2. Invalidate Supabase session
    await supabase.auth.signOut();

    // 3. Clear browser storage
    localStorage.clear();
    sessionStorage.clear();

    // 4. Clear React Query cache
    queryClient.clear();

    // 5. Mark session as inactive in database
    if (sessionId) {
      await supabase
        .from('sessions')
        .update({ is_active: false })
        .eq('user_id', sessionId)
        .eq('is_active', true);
    }

    // 6. Clear any custom cookies (if used)
    document.cookie.split(';').forEach((c) => {
      document.cookie = c
        .replace(/^ +/, '')
        .replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');
    });

    // 7. Redirect to login
    window.location.href = '/login';
  } catch (error) {
    console.error('Logout error:', error);
    // Force redirect even on error
    window.location.href = '/login';
  }
}
```

**File Locations:**
- Create: src/hooks/useSessionTimeout.ts (session timeout hook)
- Create: src/utils/rateLimiting.ts (rate limiting utility)
- Create: src/utils/passwordValidation.ts (password strength validation)
- Create: src/utils/authErrors.ts (error message mapping)
- Create: src/utils/logout.ts (secure logout utility)
- Create: src/components/security/TwoFactorSetup.tsx (2FA enrollment UI)
- Create: src/components/security/ActiveSessions.tsx (session monitoring UI)
- Create: src/components/security/PasswordResetForm.tsx (password reset UI)
- Create: src/components/security/SecurityDashboard.tsx (security settings page)
- Create: .ai/migrations/create-login-attempts-table.sql (database migration)
- Create: .ai/migrations/create-sessions-table.sql (database migration)
- Update: src/components/auth/LoginForm.tsx (add rate limiting, error handling)
- Update: src/components/Settings.tsx (add security dashboard section)
- Update: .ai/security-checklist.md (add authentication verification steps)

### Testing

**Testing Requirements:** [Source: docs/prd/technical-assumptions.md]
Manual testing with systematic verification (no automated test suite per PRD)

**Authentication Security Validation Workflow:**

1. **Password Complexity Testing:**
   - Attempt signup with weak password: "abc123" → verify rejected
   - Attempt password: "Abcdefg1234" (no special char) → verify rejected
   - Attempt password: "Abcd123!@#$" (12+ chars, all requirements) → verify accepted
   - Test password strength indicator shows: Weak, Moderate, Strong

2. **Session Timeout Testing:**
   - Login to dashboard
   - Leave inactive for 19 hours (simulate with date manipulation or wait)
   - Return to dashboard → verify warning appears: "Session expiring in 5 minutes"
   - Click "Continue" → verify session extended
   - Leave inactive for 24 hours total → verify logged out automatically
   - Attempt to access protected page after timeout → verify redirected to login

3. **Rate Limiting Testing:**
   - Attempt login with wrong password 5 times
   - Verify: "Remaining attempts: 4, 3, 2, 1, 0"
   - On 6th attempt: verify blocked with message "Too many failed attempts. Try again in 15 minutes."
   - Wait 15 minutes → attempt login → verify allowed again
   - Check email for lockout notification

4. **2FA Enrollment Testing:**
   - Navigate to Settings → Security → Enable 2FA
   - Click "Enable 2FA" → verify QR code displayed
   - Scan QR code with Google Authenticator app
   - Enter 6-digit code from app → verify accepted
   - Save backup codes displayed
   - Logout and login again → verify prompted for 6-digit code
   - Enter code → verify login succeeds
   - Test backup code: use backup code instead of authenticator → verify works once

5. **Password Reset Flow Testing:**
   - Click "Forgot Password" on login page
   - Enter email → verify "Check your email" message
   - Check email inbox → verify reset link received
   - Click reset link → verify redirected to password reset page
   - Enter new password → verify complexity validated
   - Submit → verify "Password updated successfully"
   - Attempt old password → verify fails
   - Login with new password → verify succeeds
   - Wait 20 minutes → attempt to use same reset link → verify expired

6. **Active Session Monitoring Testing:**
   - Login from desktop browser → note timestamp
   - Navigate to Settings → Security → Active Sessions
   - Verify current session listed with device info
   - Login from mobile device (or different browser)
   - Refresh active sessions list → verify both sessions shown
   - Click "Revoke" on mobile session → verify removed
   - Attempt action on mobile device → verify requires re-login
   - Click "Revoke All Other Sessions" → verify only current session remains

7. **Secure Logout Testing:**
   - Login and create some data (tasks, projects)
   - Click logout button
   - Verify redirected to login page
   - Check browser DevTools → Application → Local Storage → verify empty
   - Check Session Storage → verify empty
   - Use browser back button → verify cannot access dashboard (redirected to login)
   - Check browser Network tab → verify no auth tokens in subsequent requests

8. **Authentication Error Handling Testing:**
   - Attempt login with non-existent email → verify message: "Invalid email or password" (not "User not found")
   - Attempt login with correct email, wrong password → verify same message: "Invalid email or password"
   - Attempt login with unverified email (if email verification enabled) → verify: "Please verify your email address"
   - Check browser console in production → verify no detailed error messages exposed

9. **Last Login Display Testing:**
   - Login to dashboard
   - Navigate to dashboard → verify header or settings shows "Last login: [timestamp]"
   - Logout and login again
   - Verify "Last login" timestamp updated to new login time
   - Login from different device → verify shows device info: "Last login from Chrome on Windows at [time]"

10. **End-to-End Authentication Security:**
    - Create new user account with strong password
    - Enable 2FA and save backup codes
    - Login with 2FA from desktop
    - Open dashboard in incognito window → verify requires login (no session sharing)
    - In main window: create sensitive data (finance records)
    - In incognito: attempt to login with wrong password 6 times → verify locked out
    - In main window: leave inactive for 24+ hours → verify auto-logout
    - Login again → verify all data still accessible (not lost)
    - Click forgot password → reset password → verify old password no longer works
    - Login with new password and 2FA → verify access granted
    - Review active sessions → revoke all → verify logged out

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
