# Story 1.6: Tasks Hub Performance Optimization & Error Handling

## Status
Draft

## Story
**As a** power user with 100+ active tasks,
**I want** the Tasks hub to load quickly and handle sync errors gracefully,
**so that** the dashboard remains responsive and reliable during high-volume usage.

## Acceptance Criteria
1. Tasks hub page loads in <2 seconds with 100+ tasks displayed
2. Task sync operations complete in <500ms (95th percentile performance)
3. Database queries use proper indexing on `business_id`, `due_date`, `status`, and `user_id` columns for <100ms response time
4. Sync failures display user-friendly error messages (not raw database errors)
5. Failed sync operations retry automatically up to 3 times with exponential backoff
6. Tasks hub implements virtual scrolling for lists exceeding 50 tasks to maintain smooth scrolling performance
7. Sync status indicator shows when syncing is in progress (subtle spinner or pulse animation)
8. Manual refresh button allows forcing a full sync if automatic sync appears stuck
9. Error log captures sync failures with timestamp, affected task ID, and error details for debugging

## Tasks / Subtasks
- [ ] Task 1: Optimize database queries and indexing (AC: 3)
  - [ ] Verify indexes exist on tasks table: business_id, due_date, status, user_id, scheduled_date
  - [ ] Create composite index on (user_id, status, due_date) for common queries
  - [ ] Use EXPLAIN ANALYZE in Supabase SQL editor to verify query plans use indexes
  - [ ] Optimize Supabase select queries to only fetch needed columns (avoid `SELECT *` when possible)
  - [ ] Measure query response time in Network tab (must be <100ms)
- [ ] Task 2: Implement React Query caching strategy (AC: 1, 2)
  - [ ] Configure React Query staleTime: 5 minutes, gcTime: 10 minutes in queryClient.ts
  - [ ] Use prefetching for predictable navigation (e.g., prefetch Tasks Hub when user hovers on nav link)
  - [ ] Enable background refetching to keep data fresh without blocking UI
  - [ ] Use optimistic updates for mutations to provide instant UI feedback (<500ms perceived latency)
  - [ ] Cache tasks by queryKey hierarchy: ['tasks'], ['tasks', 'business', id], ['tasks', 'daily', date]
- [ ] Task 3: Add automatic retry logic with exponential backoff (AC: 5)
  - [ ] Configure React Query retry: 3 attempts with retryDelay formula
  - [ ] Implement exponential backoff: 1st retry after 1s, 2nd after 2s, 3rd after 4s
  - [ ] Log retry attempts to console in development mode
  - [ ] Show "Retrying..." message during retry attempts
  - [ ] After 3 failed retries, show persistent error notification with manual retry button
- [ ] Task 4: Implement user-friendly error handling (AC: 4)
  - [ ] Create src/utils/errorMessages.ts with error message mapping
  - [ ] Map Supabase error codes to friendly messages:
    - [ ] 23505 (unique violation) → "This task already exists"
    - [ ] 23503 (FK violation) → "Cannot link to non-existent project"
    - [ ] 42501 (insufficient privilege) → "Permission denied. Please refresh and log in again."
    - [ ] PGRST116 (no rows) → "Task not found. It may have been deleted."
  - [ ] Display errors in toast notifications (not alert() popups)
  - [ ] Log full error details to console for developer debugging
- [ ] Task 5: Implement virtual scrolling for large task lists (AC: 6)
  - [ ] Install react-virtual or @tanstack/react-virtual library
  - [ ] Wrap TasksHub task list in VirtualList component
  - [ ] Configure row height (estimate: 100px per TaskCard)
  - [ ] Enable virtual scrolling when task count > 50
  - [ ] Test smooth scrolling with 200+ tasks using `__test.seedData()`
  - [ ] Measure FPS during scrolling (should maintain 60fps)
- [ ] Task 6: Add sync status indicators (AC: 7)
  - [ ] Create src/components/shared/SyncStatusIndicator.tsx component
  - [ ] Show spinner icon with pulse animation when React Query isFetching = true
  - [ ] Show checkmark icon when sync completes successfully
  - [ ] Show error icon with tooltip when sync fails
  - [ ] Display global sync status in Tasks Hub header
  - [ ] Use Lucide icons: RefreshCw (syncing), Check (success), AlertCircle (error)
- [ ] Task 7: Add manual refresh button (AC: 8)
  - [ ] Add "Refresh" button in Tasks Hub header
  - [ ] Clicking refresh calls queryClient.invalidateQueries(['tasks']) to force refetch
  - [ ] Show loading spinner on button during refresh
  - [ ] Disable button during refresh to prevent double-click
  - [ ] Display "Last synced: X minutes ago" timestamp
  - [ ] Auto-refresh every 5 minutes if user is active on page
- [ ] Task 8: Implement comprehensive error logging (AC: 9)
  - [ ] Create src/utils/errorLogger.ts for centralized error logging
  - [ ] Log sync errors with: timestamp, user_id, task_id, operation (INSERT/UPDATE/DELETE), error_code, error_message
  - [ ] In production, send error logs to Supabase error_logs table (create table if needed)
  - [ ] In development, log errors to console with styled formatting
  - [ ] Create error dashboard page for viewing error history (future enhancement, log structure only)
- [ ] Task 9: Measure and optimize page load performance (AC: 1)
  - [ ] Use React Profiler to measure component render time
  - [ ] Use Lighthouse in Chrome DevTools to audit page performance
  - [ ] Optimize bundle size: code-split routes with React.lazy()
  - [ ] Lazy-load TaskCard components for virtual scrolling
  - [ ] Measure Time to Interactive (TTI) with 100+ tasks (must be <2 seconds)
  - [ ] Consider using React.memo() for TaskCard to prevent unnecessary re-renders
- [ ] Task 10: Load testing and performance verification (AC: all)
  - [ ] Use `__test.seedData()` to create 200+ tasks
  - [ ] Measure page load time with Performance tab (must be <2s)
  - [ ] Measure sync latency with `__test.testSync()` (must be <500ms for 95th percentile)
  - [ ] Test query response time in Network tab (must be <100ms)
  - [ ] Test virtual scrolling smoothness with 200+ tasks
  - [ ] Simulate slow network (Chrome DevTools → Fast 3G throttling) → verify retry logic
  - [ ] Simulate failed sync (disconnect network mid-operation) → verify error handling

## Dev Notes

### Previous Story Insights
**From Story 1.1:** [Source: docs/stories/1.1.tasks-hub-page-structure.md]
- Tasks Hub page structure complete: TasksHub.tsx, TaskCard.tsx, TaskFilters.tsx
- useTasks.ts hook uses React Query with queryKey: ['tasks']
- Database indexes already created on business_id, due_date, status, user_id

**From Stories 1.2-1.5:** [Source: docs/stories/1.2-1.5]
- Real-time sync via useRealtimeSync.ts is implemented
- Optimistic updates pattern in useTasks mutation
- Toast notifications for sync errors exist
- Multiple query keys in use: ['tasks'], ['tasks', 'business', id], ['tasks', 'daily', date], ['tasks', 'life-area', category]

**Key Technical Decisions:**
- Use React Query built-in retry mechanism (no custom retry logic needed)
- Virtual scrolling library: @tanstack/react-virtual (same ecosystem as React Query)
- Error logging stored in Supabase error_logs table for production monitoring
- Code splitting at route level (lazy load /tasks, /business, /health routes)

**Performance Bottlenecks to Address:**
- Large task lists (100+ tasks) may cause slow rendering without virtual scrolling
- Supabase queries without proper indexing can exceed 100ms
- Real-time subscriptions may cause excessive refetching if not properly debounced
- Large bundle size from importing all components upfront

### Architecture Context

**Tech Stack:** [Source: docs/ui-architecture/2-frontend-tech-stack.md]
- Frontend: React 19.1.1 + TypeScript 5.9.3
- State Management: TanStack Query 5.90.2
- Build Tool: Vite 7.1.7 (supports code splitting with React.lazy)
- Backend: Supabase JS 2.58.0

**React Query Configuration:** [Source: docs/ui-architecture/5-state-management.md#react-query-client-configuration]
```typescript
// src/lib/queryClient.ts
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
    },
    mutations: {
      retry: 1,
    },
  },
});
```

**Virtual Scrolling Implementation:**
```typescript
// src/components/tasks/TasksHub.tsx
import { useVirtualizer } from '@tanstack/react-virtual';

const parentRef = useRef<HTMLDivElement>(null);

const virtualizer = useVirtualizer({
  count: tasks.length,
  getScrollElement: () => parentRef.current,
  estimateSize: () => 100, // Estimated TaskCard height
  overscan: 5, // Render 5 extra items above/below viewport
});

return (
  <div ref={parentRef} className="h-screen overflow-auto">
    <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
      {virtualizer.getVirtualItems().map(virtualItem => (
        <div key={virtualItem.key} style={{ transform: `translateY(${virtualItem.start}px)` }}>
          <TaskCard task={tasks[virtualItem.index]} />
        </div>
      ))}
    </div>
  </div>
);
```

**Database Indexes to Verify:**
```sql
-- Check existing indexes
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'tasks';

-- Create composite index for common query pattern
CREATE INDEX idx_tasks_user_status_date ON tasks(user_id, status, due_date);

-- Create index for scheduled date filtering (from Story 1.4)
CREATE INDEX idx_tasks_scheduled_date ON tasks(scheduled_date) WHERE scheduled_date IS NOT NULL;

-- Analyze query performance
EXPLAIN ANALYZE
SELECT * FROM tasks
WHERE user_id = 'user-uuid'
  AND status = 'active'
ORDER BY due_date ASC;
```

**Error Message Mapping:** [Source: docs/ui-architecture/6-api-integration.md + Supabase docs]
- Supabase error codes: https://supabase.com/docs/guides/api/rest/error-codes
- Map PostgreSQL error codes (23xxx) to user-friendly messages
- Generic fallback: "Something went wrong. Please try again."

**Code Splitting Strategy:**
```typescript
// src/App.tsx
import { lazy, Suspense } from 'react';

const TasksHub = lazy(() => import('./components/tasks/TasksHub'));
const BusinessDashboard = lazy(() => import('./components/business/BusinessDashboard'));
const HealthDashboard = lazy(() => import('./components/health/HealthDashboard'));

// Wrap routes in Suspense with loading fallback
<Suspense fallback={<Spinner />}>
  <Route path="/tasks" element={<TasksHub />} />
  <Route path="/business/:id" element={<BusinessDashboard />} />
  <Route path="/health" element={<HealthDashboard />} />
</Suspense>
```

**Performance Monitoring Tools:**
- React DevTools Profiler: Measure component render time
- Chrome DevTools Performance tab: Measure TTI, FPS, frame drops
- Chrome DevTools Network tab: Measure query response time
- Lighthouse: Overall performance score (target: 90+)

**Performance Requirements:** [Source: docs/prd/technical-assumptions.md]
- Page load <2s (Time to Interactive)
- Task sync latency <500ms (95th percentile)
- Database queries <100ms response time
- Support 100+ concurrent active tasks

**Error Logging Schema:**
```sql
-- Create error_logs table for production monitoring
CREATE TABLE error_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  task_id UUID REFERENCES tasks(id),
  operation TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE', 'QUERY'
  error_code TEXT,
  error_message TEXT,
  stack_trace TEXT,
  metadata JSONB -- Additional context
);

-- RLS policy
ALTER TABLE error_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY error_logs_user_policy ON error_logs FOR ALL USING (auth.uid() = user_id);
```

**File Locations for This Story:**
- Update: src/lib/queryClient.ts (configure retry and caching)
- Create: src/utils/errorMessages.ts (error message mapping)
- Create: src/utils/errorLogger.ts (error logging utility)
- Update: src/components/tasks/TasksHub.tsx (add virtual scrolling)
- Create: src/components/shared/SyncStatusIndicator.tsx (sync status UI)
- Update: src/App.tsx (add code splitting with React.lazy)
- Create: error-logs-table.sql (create error logging table)
- Update: src/components/tasks/TaskCard.tsx (add React.memo for performance)

### Testing

**Testing Strategy:** [Source: docs/ui-architecture/9-testing-requirements.md]
Manual testing with convenience methods

**Load Testing Approach:**
1. Create 200+ tasks using `__test.seedData()`
2. Measure page load with Performance tab
3. Measure query time with Network tab
4. Measure FPS during scrolling with Performance monitor

**Testing Requirements for This Story:**
1. Verify all 9 acceptance criteria manually
2. Test page load with 100+ tasks → must be <2 seconds (measure with Lighthouse)
3. Test sync latency with `__test.testSync()` → must be <500ms for 95th percentile
4. Test database query performance → verify <100ms in Network tab
5. Test error handling: force Supabase error (e.g., unique violation) → verify friendly error message
6. Test retry logic: simulate network failure → verify 3 retry attempts with exponential backoff
7. Test virtual scrolling: scroll through 200+ tasks → verify smooth 60fps scrolling
8. Test sync status indicator: make update → verify spinner shows during sync, checkmark after success
9. Test manual refresh button: click refresh → verify tasks refetch from database
10. Test error logging: cause sync error → verify error logged to error_logs table

**Performance Benchmarks to Record:**
- Page load time (target: <2s)
- Query response time (target: <100ms)
- Sync latency (target: <500ms for 95th percentile)
- FPS during scrolling (target: 60fps)
- Lighthouse Performance score (target: 90+)

**Test Helpers to Create:**
- `__test.seedData(count)` - Create N tasks for load testing
- `__test.testSync(taskId)` - Measure sync latency
- `__test.clearCache()` - Clear React Query cache
- `__test.measureQueryTime()` - Benchmark database query performance

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
