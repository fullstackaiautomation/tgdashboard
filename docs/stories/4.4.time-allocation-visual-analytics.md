# Story 4.4: Time Allocation Visual Analytics Dashboard

## Status
Draft

## Story
**As a** data-driven operator,
**I want** visual analytics showing time allocation patterns and trends,
**so that** I can identify productivity patterns and optimize how I distribute attention across my 7 life areas.

## Acceptance Criteria
1. Analytics dashboard (from Story 4.2 /analytics page) includes comprehensive time allocation visualizations
2. Weekly heatmap: color-coded grid showing hours per area per day (darker = more hours) for all 7 areas
3. Area distribution pie chart: % of total time spent on each of 7 areas (Full Stack, S4, 808, Personal, Huge Capital, Golf, Health) over selected date range
4. Trend analysis: line graph showing how time allocation across areas has shifted over last 3 months
5. "Focus time" metric: % of total hours logged as Deep Work sessions (vs. untracked time)
6. Peak productivity analysis: what times of day have most Deep Work sessions logged (morning/afternoon/evening breakdown)
7. Project-level time tracking: for each project, show total hours invested and hours per phase
8. Label analysis: time spent on different activity types (e.g., "Internal Build": 20h, "Client Meetings": 5h, "Bug Fixes": 8h)
9. Comparison view: current week vs. last week time allocation side-by-side to spot dramatic shifts

## Tasks / Subtasks
- [ ] Task 1: Create Time Analytics dashboard page and routing (AC: 1)
  - [ ] Create src/pages/TimeAnalytics.tsx as new dashboard page
  - [ ] Add route: /analytics/time in App.tsx router
  - [ ] Add navigation link in main navigation: "Time Analytics" with chart icon
  - [ ] Page layout: Grid of analytics cards/widgets, full-width charts
  - [ ] Header: Title "Time Allocation Analytics" + date range selector
  - [ ] Date range options: This Week, This Month, Last 3 Months, Custom Range
  - [ ] Export entire dashboard as PDF report button
  - [ ] Responsive: Stack widgets vertically on mobile, 2-column grid on desktop
- [ ] Task 2: Build weekly heatmap visualization (AC: 2)
  - [ ] Create src/components/analytics/WeeklyHeatmap.tsx using Recharts or custom SVG
  - [ ] Query: SELECT DATE(start_time) as day, business_id, SUM(duration_minutes) / 60.0 as hours FROM deep_work_sessions WHERE start_time >= week_start GROUP BY day, business_id
  - [ ] Grid layout: Y-axis = businesses (Full Stack, Huge Capital, S4, 808, Service SaaS), X-axis = days (Mon-Sun)
  - [ ] Color intensity: 0h = white, 1-2h = light blue, 3-5h = medium blue, 6+h = dark blue
  - [ ] Cell hover: Show tooltip with exact hours and business name
  - [ ] Click cell: Navigate to that business's detail page filtered to that day
  - [ ] Legend: Color scale showing hours-to-color mapping
  - [ ] Alternative: Use library like react-calendar-heatmap or custom D3 implementation
  - [ ] Integration: Top section of Time Analytics page (full width)
- [ ] Task 3: Create business distribution pie chart (AC: 3)
  - [ ] Create src/components/analytics/BusinessDistributionPieChart.tsx using Recharts
  - [ ] Query: SELECT business_id, SUM(duration_minutes) / 60.0 as hours FROM deep_work_sessions WHERE start_time >= date_range_start GROUP BY business_id
  - [ ] Calculate percentages: (business_hours / total_hours) * 100
  - [ ] Pie chart: Each business as colored slice matching business color from database
  - [ ] Labels: Show business name + percentage on each slice
  - [ ] Legend: List of businesses with colors and exact hours
  - [ ] Center label: Total hours for date range
  - [ ] Hover: Highlight slice and show detailed tooltip
  - [ ] Click slice: Navigate to Business detail page
  - [ ] Integration: Left column widget on Time Analytics page
- [ ] Task 4: Build life balance pie chart (AC: 4)
  - [ ] Create src/components/analytics/LifeBalancePieChart.tsx using Recharts
  - [ ] Query: Aggregate all businesses into "Business" category, separate life areas (Health, Content, Golf, Personal)
  - [ ] Categories: Business (sum of all business_id), Health, Content, Golf, Personal
  - [ ] Calculate: SELECT CASE WHEN business_id IS NOT NULL THEN 'Business' ELSE la.name END as category, SUM(duration_minutes) / 60.0 FROM deep_work_sessions
  - [ ] Pie chart: 5 slices for main life categories
  - [ ] Color scheme: Business (blue), Health (red), Content (purple), Golf (green), Personal (yellow)
  - [ ] Show percentages: "Business: 60%, Health: 15%, Content: 10%, Golf: 5%, Personal: 10%"
  - [ ] Balance indicator: If Business > 80%, show warning: "⚠️ Heavy business focus - consider life balance"
  - [ ] Ideal balance overlay: Show dotted line for recommended distribution
  - [ ] Integration: Right column widget next to Business Distribution
- [ ] Task 5: Implement 3-month trend analysis line graph (AC: 5)
  - [ ] Create src/components/analytics/TimeAllocationTrendGraph.tsx using Recharts LineChart
  - [ ] Query: SELECT DATE(start_time), business_id, SUM(duration_minutes) / 60.0 FROM deep_work_sessions WHERE start_time >= NOW() - INTERVAL '3 months' GROUP BY DATE(start_time), business_id
  - [ ] X-axis: Dates (last 90 days) with weekly labels
  - [ ] Y-axis: Hours per day
  - [ ] Multiple lines: One line per business with distinct colors
  - [ ] Smooth curves: Use monotone interpolation for cleaner visuals
  - [ ] Aggregate options: Show daily, weekly average, or monthly totals
  - [ ] Legend: Toggle visibility of each business line
  - [ ] Zoom/pan: Allow selecting date range within 3 months for detailed view
  - [ ] Annotations: Mark significant events (project launches, vacations)
  - [ ] Integration: Full-width chart below pie charts
- [ ] Task 6: Build focus time metric calculation (AC: 6)
  - [ ] Create src/components/analytics/FocusTimeMetric.tsx
  - [ ] Calculate total tracked Deep Work hours: SELECT SUM(duration_minutes) / 60.0 FROM deep_work_sessions WHERE start_time >= date_range
  - [ ] Estimate total available work hours: (work_days * hours_per_day) for date range
  - [ ] Focus percentage: (tracked_hours / available_hours) * 100
  - [ ] Display: Large percentage with progress ring: "65% Focus Time"
  - [ ] Comparison: "You tracked 65% of your work hours (130h / 200h available)"
  - [ ] Color-code: >=70% green (excellent), 50-69% yellow (good), <50% red (improve tracking)
  - [ ] Insights: "You're tracking most of your time - keep it up!" or "Consider tracking more hours for better insights"
  - [ ] Integration: Hero metric card at top of Time Analytics page
- [ ] Task 7: Create peak productivity time-of-day analysis (AC: 7)
  - [ ] Create src/components/analytics/PeakProductivityChart.tsx using Recharts BarChart
  - [ ] Query: SELECT EXTRACT(HOUR FROM start_time) as hour, COUNT(*) as session_count, SUM(duration_minutes) / 60.0 as hours FROM deep_work_sessions GROUP BY hour
  - [ ] Time buckets: Morning (6-11 AM), Afternoon (12-5 PM), Evening (6-11 PM), Night (12-5 AM)
  - [ ] Bar chart: X-axis = time buckets, Y-axis = total hours
  - [ ] Show both session count and total hours per bucket
  - [ ] Detailed hourly view: 24-hour bar chart showing hours per hour (0-23)
  - [ ] Highlight peak hour: Bold/colored bar for hour with most Deep Work
  - [ ] Insight: "You're most productive in the Morning (42h, 35% of total)"
  - [ ] Recommendation: "Schedule deep work tasks during morning hours for optimal performance"
  - [ ] Integration: Middle section of Time Analytics page
- [ ] Task 8: Implement project-level time tracking visualization (AC: 8)
  - [ ] Create src/components/analytics/ProjectTimeTable.tsx
  - [ ] Query: SELECT p.id, p.name, SUM(dws.duration_minutes) / 60.0 as total_hours FROM deep_work_sessions dws JOIN projects p ON dws.project_id = p.id GROUP BY p.id, p.name
  - [ ] Table columns: Project Name | Business | Total Hours | Hours per Phase | Progress
  - [ ] Hours per phase: Subquery to breakdown time by phase_id within each project
  - [ ] Sort options: By most hours, by business, by completion %
  - [ ] Click project row: Navigate to Project detail page
  - [ ] Export as CSV: Project time breakdown for reporting
  - [ ] Visual: Horizontal bar showing relative time investment per project
  - [ ] Filter: By business, by date range
  - [ ] Integration: Expandable section on Time Analytics page
- [ ] Task 9: Build label-based time analysis (AC: 9)
  - [ ] Create src/components/analytics/LabelTimeAnalysis.tsx using Recharts
  - [ ] Query: SELECT UNNEST(labels) as label, COUNT(*) as session_count, SUM(duration_minutes) / 60.0 as hours FROM deep_work_sessions GROUP BY label ORDER BY hours DESC
  - [ ] Horizontal bar chart: Labels on Y-axis, hours on X-axis
  - [ ] Top 10 labels displayed by default, "Show All" button for complete list
  - [ ] Color-code labels: Revenue-generating ($$$) in green, Internal in blue, Meetings in gray
  - [ ] Percentage of total: "Internal Build: 20h (25% of total time)"
  - [ ] Click label bar: Filter to show all sessions with that label
  - [ ] Insights: "You spent 40% of time on revenue-generating work ($$$)"
  - [ ] Recommendation: "Consider reducing meeting time (15h) to focus on high-value work"
  - [ ] Integration: Full-width widget on Time Analytics page
- [ ] Task 10: Create week-over-week comparison view (AC: 10)
  - [ ] Create src/components/analytics/WeekComparisonView.tsx
  - [ ] Query current week: SELECT business_id, SUM(duration_minutes) / 60.0 FROM deep_work_sessions WHERE start_time >= current_week_start GROUP BY business_id
  - [ ] Query last week: Same query with last_week_start
  - [ ] Side-by-side bar chart: Grouped bars showing This Week vs Last Week for each business
  - [ ] Delta indicators: Show change (± hours and %) for each business
  - [ ] Highlight dramatic shifts: If business hours change >50%, highlight with warning icon
  - [ ] Total row: Sum of all businesses this week vs last week
  - [ ] Insights: "Full Stack AI: +5h (↑50%), Huge Capital: -3h (↓30%)"
  - [ ] Explanation suggestions: "Full Stack AI surge may indicate project deadline approaching"
  - [ ] Integration: Bottom section of Time Analytics page (collapsible)

## Dev Notes

### Previous Story Insights
**From Story 4.1:** [Source: docs/stories/4.1.deep-work-time-allocation-calculation.md]
- deep_work_sessions table with business_id, life_area_id, project_id, labels, start_time, duration_minutes
- Aggregation SQL functions for daily, weekly, monthly calculations
- Recharts integration established for React-compatible charts
- CSV export utility pattern

**From Story 4.2:** [Source: docs/stories/4.2.business-time-investment-dashboard.md]
- Business-level time stats with materialized views for performance
- Project time breakdown queries and visualizations
- Label time breakdown patterns
- Historical trend line charts with Recharts

**From Story 4.3:** [Source: docs/stories/4.3.health-goal-time-monitoring.md]
- Life area time aggregation (Health tracking)
- Warning systems and alert indicators
- Streak tracking for positive reinforcement
- Week-over-week comparison patterns

**From Epic 2 Stories:** [Source: docs/stories/2.6]
- Review dashboard aggregation patterns
- Multi-level data rollup strategies
- Visual progress indicators and color-coding
- Recharts integration for complex visualizations

**Key Technical Context:**
- This is the FOURTH story in Epic 4 - consolidates all time data into comprehensive analytics dashboard
- Analytics page is read-only (no editing) - purely for insights and pattern recognition
- Heavy use of Recharts for consistent, React-compatible visualizations
- Performance critical: Use materialized views, indexes, and caching
- Date range selector affects all visualizations simultaneously

### Architecture Context

**Tech Stack:** [Source: docs/ui-architecture/2-frontend-tech-stack.md]
- React 19.1.1 + TypeScript 5.9.3
- TanStack Query 5.90.2 for data fetching and caching
- Recharts 2.x for all chart visualizations
- date-fns 4.1.0 for date range calculations
- Lucide React 0.544.0 for icons

**Database Query Optimization**
```sql
-- Create materialized view for analytics dashboard (refreshed hourly)
CREATE MATERIALIZED VIEW time_analytics_summary AS
SELECT
  DATE(start_time) as day,
  business_id,
  life_area_id,
  EXTRACT(HOUR FROM start_time) as hour_of_day,
  labels,
  SUM(duration_minutes) / 60.0 as hours,
  COUNT(*) as session_count
FROM deep_work_sessions
WHERE start_time >= NOW() - INTERVAL '3 months'
GROUP BY DATE(start_time), business_id, life_area_id, EXTRACT(HOUR FROM start_time), labels;

CREATE INDEX idx_analytics_day ON time_analytics_summary(day);
CREATE INDEX idx_analytics_business ON time_analytics_summary(business_id);
CREATE INDEX idx_analytics_life_area ON time_analytics_summary(life_area_id);

-- Refresh function (call from scheduled job)
CREATE OR REPLACE FUNCTION refresh_time_analytics()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY time_analytics_summary;
END;
$$ LANGUAGE plpgsql;

-- Weekly heatmap query
CREATE OR REPLACE FUNCTION get_weekly_heatmap(
  p_user_id UUID,
  p_week_start DATE
)
RETURNS TABLE(
  day_date DATE,
  business_id UUID,
  business_name TEXT,
  hours NUMERIC
) AS $$
  SELECT
    DATE(dws.start_time) as day_date,
    b.id as business_id,
    b.name as business_name,
    ROUND(SUM(dws.duration_minutes) / 60.0, 2) as hours
  FROM deep_work_sessions dws
  JOIN businesses b ON dws.business_id = b.id
  WHERE dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_week_start
    AND DATE(dws.start_time) < p_week_start + INTERVAL '7 days'
  GROUP BY DATE(dws.start_time), b.id, b.name
  ORDER BY day_date, business_name;
$$ LANGUAGE SQL STABLE;

-- Business distribution query
CREATE OR REPLACE FUNCTION get_business_distribution(
  p_user_id UUID,
  p_start_date DATE,
  p_end_date DATE
)
RETURNS TABLE(
  business_id UUID,
  business_name TEXT,
  business_color TEXT,
  hours NUMERIC,
  percentage NUMERIC
) AS $$
WITH business_hours AS (
  SELECT
    b.id as business_id,
    b.name as business_name,
    b.color as business_color,
    SUM(dws.duration_minutes) / 60.0 as hours
  FROM deep_work_sessions dws
  JOIN businesses b ON dws.business_id = b.id
  WHERE dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_start_date
    AND DATE(dws.start_time) <= p_end_date
  GROUP BY b.id, b.name, b.color
),
total_hours AS (
  SELECT SUM(hours) as total FROM business_hours
)
SELECT
  bh.business_id,
  bh.business_name,
  bh.business_color,
  ROUND(bh.hours, 2) as hours,
  ROUND((bh.hours / th.total) * 100, 1) as percentage
FROM business_hours bh, total_hours th
ORDER BY hours DESC;
$$ LANGUAGE SQL STABLE;

-- Life balance query
CREATE OR REPLACE FUNCTION get_life_balance(
  p_user_id UUID,
  p_start_date DATE,
  p_end_date DATE
)
RETURNS TABLE(
  category TEXT,
  hours NUMERIC,
  percentage NUMERIC
) AS $$
WITH category_hours AS (
  SELECT
    CASE
      WHEN dws.business_id IS NOT NULL THEN 'Business'
      ELSE COALESCE(la.name, 'Unallocated')
    END as category,
    SUM(dws.duration_minutes) / 60.0 as hours
  FROM deep_work_sessions dws
  LEFT JOIN life_areas la ON dws.life_area_id = la.id
  WHERE dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_start_date
    AND DATE(dws.start_time) <= p_end_date
  GROUP BY category
),
total_hours AS (
  SELECT SUM(hours) as total FROM category_hours
)
SELECT
  ch.category,
  ROUND(ch.hours, 2) as hours,
  ROUND((ch.hours / th.total) * 100, 1) as percentage
FROM category_hours ch, total_hours th
ORDER BY hours DESC;
$$ LANGUAGE SQL STABLE;

-- Peak productivity hours query
CREATE OR REPLACE FUNCTION get_peak_productivity(
  p_user_id UUID,
  p_start_date DATE,
  p_end_date DATE
)
RETURNS TABLE(
  hour_of_day INTEGER,
  session_count INTEGER,
  total_hours NUMERIC
) AS $$
  SELECT
    EXTRACT(HOUR FROM start_time)::INTEGER as hour_of_day,
    COUNT(*)::INTEGER as session_count,
    ROUND(SUM(duration_minutes) / 60.0, 2) as total_hours
  FROM deep_work_sessions
  WHERE user_id = p_user_id
    AND DATE(start_time) >= p_start_date
    AND DATE(start_time) <= p_end_date
  GROUP BY EXTRACT(HOUR FROM start_time)
  ORDER BY hour_of_day;
$$ LANGUAGE SQL STABLE;

-- Label time analysis query
CREATE OR REPLACE FUNCTION get_label_analysis(
  p_user_id UUID,
  p_start_date DATE,
  p_end_date DATE
)
RETURNS TABLE(
  label TEXT,
  session_count INTEGER,
  total_hours NUMERIC,
  percentage NUMERIC
) AS $$
WITH label_hours AS (
  SELECT
    UNNEST(labels) as label,
    COUNT(*)::INTEGER as session_count,
    SUM(duration_minutes) / 60.0 as total_hours
  FROM deep_work_sessions
  WHERE user_id = p_user_id
    AND DATE(start_time) >= p_start_date
    AND DATE(start_time) <= p_end_date
    AND labels IS NOT NULL
    AND array_length(labels, 1) > 0
  GROUP BY label
),
total_hours AS (
  SELECT SUM(duration_minutes) / 60.0 as total
  FROM deep_work_sessions
  WHERE user_id = p_user_id
    AND DATE(start_time) >= p_start_date
    AND DATE(start_time) <= p_end_date
)
SELECT
  lh.label,
  lh.session_count,
  ROUND(lh.total_hours, 2) as total_hours,
  ROUND((lh.total_hours / th.total) * 100, 1) as percentage
FROM label_hours lh, total_hours th
ORDER BY total_hours DESC;
$$ LANGUAGE SQL STABLE;
```

**React Query Hooks Pattern**
```typescript
// src/hooks/useTimeAnalytics.ts
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase';
import { startOfWeek, format } from 'date-fns';

interface DateRange {
  start: Date;
  end: Date;
}

export const useWeeklyHeatmap = (weekStart: Date) => {
  return useQuery({
    queryKey: ['weekly-heatmap', format(weekStart, 'yyyy-MM-dd')],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('get_weekly_heatmap', {
        p_user_id: user.id,
        p_week_start: format(weekStart, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data as Array<{
        day_date: string;
        business_id: string;
        business_name: string;
        hours: number;
      }>;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

export const useBusinessDistribution = (dateRange: DateRange) => {
  return useQuery({
    queryKey: ['business-distribution', dateRange],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('get_business_distribution', {
        p_user_id: user.id,
        p_start_date: format(dateRange.start, 'yyyy-MM-dd'),
        p_end_date: format(dateRange.end, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data as Array<{
        business_id: string;
        business_name: string;
        business_color: string;
        hours: number;
        percentage: number;
      }>;
    },
  });
};

export const useLifeBalance = (dateRange: DateRange) => {
  return useQuery({
    queryKey: ['life-balance', dateRange],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('get_life_balance', {
        p_user_id: user.id,
        p_start_date: format(dateRange.start, 'yyyy-MM-dd'),
        p_end_date: format(dateRange.end, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data as Array<{
        category: string;
        hours: number;
        percentage: number;
      }>;
    },
  });
};

export const usePeakProductivity = (dateRange: DateRange) => {
  return useQuery({
    queryKey: ['peak-productivity', dateRange],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('get_peak_productivity', {
        p_user_id: user.id,
        p_start_date: format(dateRange.start, 'yyyy-MM-dd'),
        p_end_date: format(dateRange.end, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data as Array<{
        hour_of_day: number;
        session_count: number;
        total_hours: number;
      }>;
    },
  });
};

export const useLabelAnalysis = (dateRange: DateRange) => {
  return useQuery({
    queryKey: ['label-analysis', dateRange],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('get_label_analysis', {
        p_user_id: user.id,
        p_start_date: format(dateRange.start, 'yyyy-MM-dd'),
        p_end_date: format(dateRange.end, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data as Array<{
        label: string;
        session_count: number;
        total_hours: number;
        percentage: number;
      }>;
    },
  });
};
```

**Recharts Component Patterns**
```typescript
// src/components/analytics/WeeklyHeatmap.tsx
import { startOfWeek } from 'date-fns';
import { useWeeklyHeatmap } from '@/hooks/useTimeAnalytics';

export const WeeklyHeatmap: React.FC = () => {
  const weekStart = startOfWeek(new Date(), { weekStartsOn: 1 });
  const { data: heatmapData, isLoading } = useWeeklyHeatmap(weekStart);

  if (isLoading) return <div>Loading heatmap...</div>;

  // Transform data into grid structure
  const businesses = [...new Set(heatmapData?.map(d => d.business_name))];
  const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

  const getColorIntensity = (hours: number) => {
    if (hours === 0) return 'bg-gray-100';
    if (hours <= 2) return 'bg-blue-200';
    if (hours <= 5) return 'bg-blue-400';
    return 'bg-blue-600';
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">Weekly Time Heatmap</h3>
      <div className="overflow-x-auto">
        <table className="w-full border-collapse">
          <thead>
            <tr>
              <th className="p-2 text-left">Business</th>
              {days.map(day => (
                <th key={day} className="p-2 text-center">{day}</th>
              ))}
            </tr>
          </thead>
          <tbody>
            {businesses.map(business => (
              <tr key={business}>
                <td className="p-2 font-medium">{business}</td>
                {days.map((day, dayIndex) => {
                  const hours = heatmapData?.find(
                    d => d.business_name === business &&
                    new Date(d.day_date).getDay() === (dayIndex + 1) % 7
                  )?.hours || 0;
                  return (
                    <td key={day} className="p-2">
                      <div
                        className={`h-12 w-full ${getColorIntensity(hours)} rounded cursor-pointer hover:opacity-80 flex items-center justify-center`}
                        title={`${business}: ${hours}h on ${day}`}
                      >
                        {hours > 0 && <span className="text-sm font-semibold">{hours.toFixed(1)}</span>}
                      </div>
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

// src/components/analytics/BusinessDistributionPieChart.tsx
import { PieChart, Pie, Cell, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { useBusinessDistribution } from '@/hooks/useTimeAnalytics';

export const BusinessDistributionPieChart: React.FC<{ dateRange: DateRange }> = ({ dateRange }) => {
  const { data, isLoading } = useBusinessDistribution(dateRange);

  if (isLoading) return <div>Loading...</div>;

  const chartData = data?.map(item => ({
    name: item.business_name,
    value: item.hours,
    color: item.business_color,
    percentage: item.percentage,
  }));

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">Business Distribution</h3>
      <ResponsiveContainer width="100%" height={300}>
        <PieChart>
          <Pie
            data={chartData}
            dataKey="value"
            nameKey="name"
            cx="50%"
            cy="50%"
            outerRadius={100}
            label={({ name, percentage }) => `${name}: ${percentage}%`}
          >
            {chartData?.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={entry.color} />
            ))}
          </Pie>
          <Tooltip formatter={(value: number) => `${value.toFixed(1)}h`} />
          <Legend />
        </PieChart>
      </ResponsiveContainer>
    </div>
  );
};

// src/components/analytics/PeakProductivityChart.tsx
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { usePeakProductivity } from '@/hooks/useTimeAnalytics';

export const PeakProductivityChart: React.FC<{ dateRange: DateRange }> = ({ dateRange }) => {
  const { data, isLoading } = usePeakProductivity(dateRange);

  if (isLoading) return <div>Loading...</div>;

  const timeBuckets = [
    { name: 'Morning (6-11 AM)', start: 6, end: 11 },
    { name: 'Afternoon (12-5 PM)', start: 12, end: 17 },
    { name: 'Evening (6-11 PM)', start: 18, end: 23 },
    { name: 'Night (12-5 AM)', start: 0, end: 5 },
  ];

  const bucketData = timeBuckets.map(bucket => {
    const hours = data
      ?.filter(d => d.hour_of_day >= bucket.start && d.hour_of_day <= bucket.end)
      .reduce((sum, d) => sum + d.total_hours, 0) || 0;
    return { name: bucket.name, hours };
  });

  const peakBucket = bucketData.reduce((max, b) => b.hours > max.hours ? b : max, bucketData[0]);

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-2">Peak Productivity Times</h3>
      <p className="text-sm text-gray-600 mb-4">
        You're most productive in {peakBucket.name} ({peakBucket.hours.toFixed(1)}h, {((peakBucket.hours / bucketData.reduce((sum, b) => sum + b.hours, 0)) * 100).toFixed(0)}% of total)
      </p>
      <ResponsiveContainer width="100%" height={250}>
        <BarChart data={bucketData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" angle={-15} textAnchor="end" height={80} />
          <YAxis label={{ value: 'Hours', angle: -90, position: 'insideLeft' }} />
          <Tooltip formatter={(value: number) => `${value.toFixed(1)}h`} />
          <Bar dataKey="hours" fill="#3b82f6" />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
};
```

**File Locations:**
- Create: src/pages/TimeAnalytics.tsx (main dashboard page)
- Create: supabase-time-analytics-views.sql (materialized views and functions)
- Create: src/hooks/useTimeAnalytics.ts (React Query hooks)
- Create: src/components/analytics/WeeklyHeatmap.tsx
- Create: src/components/analytics/BusinessDistributionPieChart.tsx
- Create: src/components/analytics/LifeBalancePieChart.tsx
- Create: src/components/analytics/TimeAllocationTrendGraph.tsx
- Create: src/components/analytics/FocusTimeMetric.tsx
- Create: src/components/analytics/PeakProductivityChart.tsx
- Create: src/components/analytics/ProjectTimeTable.tsx
- Create: src/components/analytics/LabelTimeAnalysis.tsx
- Create: src/components/analytics/WeekComparisonView.tsx
- Create: src/components/analytics/DateRangeSelector.tsx
- Update: src/App.tsx (add /analytics/time route)

### Testing

**Testing Requirements:** [Source: docs/prd/technical-assumptions.md]
Manual testing with systematic verification (no automated test suite per PRD)

**Time Analytics Dashboard Validation Workflow:**
1. **Database Setup and Materialized Views:**
   - Run SQL to create time_analytics_summary materialized view
   - Create all SQL functions: get_weekly_heatmap, get_business_distribution, etc.
   - Verify materialized view populates: SELECT * FROM time_analytics_summary LIMIT 10
   - Test refresh function: SELECT refresh_time_analytics()

2. **Time Analytics Page Navigation:**
   - Navigate to main dashboard
   - Click "Time Analytics" in navigation
   - Verify route: /analytics/time loads TimeAnalytics.tsx
   - Verify page title: "Time Allocation Analytics"
   - Verify date range selector appears with options: This Week, This Month, Last 3 Months

3. **Weekly Heatmap Testing:**
   - Create varied Deep Work sessions across week for multiple businesses
   - Verify heatmap grid displays: businesses on Y-axis, days (Mon-Sun) on X-axis
   - Verify color intensity: 0h = white, 2h = light blue, 5h = medium blue, 8h = dark blue
   - Hover over cell → verify tooltip shows business name and exact hours
   - Click cell → verify navigates to Business page filtered to that day

4. **Business Distribution Pie Chart Testing:**
   - Create sessions: Full Stack (20h), Huge Capital (15h), S4 (10h), 808 (5h)
   - Verify pie chart shows 4 slices with correct proportions
   - Verify percentages: Full Stack 40%, Huge Capital 30%, S4 20%, 808 10%
   - Verify colors match business colors from database
   - Hover over slice → verify tooltip shows business name and exact hours
   - Click slice → verify navigates to Business detail page

5. **Life Balance Pie Chart Testing:**
   - Create sessions: Business (60h total), Health (10h), Content (5h), Personal (5h)
   - Verify pie chart shows: Business 75%, Health 12.5%, Content 6.25%, Personal 6.25%
   - Verify warning: "⚠️ Heavy business focus - consider life balance" (Business > 80%)
   - Test without warning: Create more Health/Content sessions → verify warning disappears

6. **3-Month Trend Analysis Testing:**
   - Create sessions across 90 days with varying daily hours
   - Verify line graph displays with X-axis = dates, Y-axis = hours
   - Verify multiple lines: one per business with distinct colors
   - Toggle business legend → verify line visibility updates
   - Test aggregation: Switch from daily to weekly → verify chart updates
   - Hover over line → verify tooltip shows date and hours

7. **Focus Time Metric Testing:**
   - Calculate: 130h tracked over 30 days (assume 200h available)
   - Verify FocusTimeMetric shows: "65% Focus Time"
   - Verify progress ring: 65% filled
   - Verify color: 65% should be yellow (good, 50-69%)
   - Test >70%: Verify green color (excellent)
   - Test <50%: Verify red color with insight to improve tracking

8. **Peak Productivity Analysis Testing:**
   - Create sessions: Morning (30h), Afternoon (20h), Evening (10h), Night (0h)
   - Verify bar chart shows 4 bars with Morning tallest
   - Verify insight: "You're most productive in Morning (30h, 50% of total)"
   - Verify recommendation: "Schedule deep work tasks during morning hours"
   - Test hourly view: Verify 24-hour bar chart shows hours per hour (0-23)

9. **Project Time Table Testing:**
   - Create sessions for 5 projects across 3 businesses
   - Verify table shows: Project Name, Business, Total Hours, Progress
   - Sort by most hours → verify project with most hours at top
   - Click project row → verify navigates to Project detail page
   - Export as CSV → verify CSV contains all project time data

10. **Label Analysis and Week Comparison Testing:**
    - Create sessions with labels: "Internal Build" (20h), "$$$ Printer $$$" (15h), "Meetings" (5h)
    - Verify horizontal bar chart shows labels ordered by hours
    - Verify revenue labels ($$$) colored green
    - Verify insight: "You spent 37.5% of time on revenue-generating work ($$$)"
    - Test Week Comparison: Create varying sessions this week vs last week
    - Verify side-by-side bars showing This Week vs Last Week for each business
    - Verify delta indicators: Full Stack AI: +5h (↑50%), Huge Capital: -3h (↓30%)
    - Verify dramatic shift highlighting: Business with >50% change highlighted

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
