# Story 4.1: Deep Work Log Time Allocation Calculation

## Status
Draft

## Story
**As someone** managing multiple life areas,
**I want** the Deep Work log to automatically calculate time invested per area,
**so that** I can see where my hours are actually going without manual time tracking.

## Acceptance Criteria
1. Each Deep Work session is tagged with: Area (one of 7: Full Stack, S4, 808, Personal, Huge Capital, Golf, Health), Project (if applicable), Task, and Labels (e.g., "Internal Build", "$$$ Printer $$$")
2. Time allocation calculation aggregates Deep Work sessions by area: Total hours per area per day/week/month
3. Time allocation displayed in multiple views:
   - Daily: "Today you spent 3h on Full Stack, 2h on Huge Capital, 1h on Health"
   - Weekly: Bar chart showing hours per area across the week
   - Monthly: Trend line showing time distribution over 30 days
4. "Unallocated time" category captures hours not tagged to specific area (should be minimized)
5. Time allocation data is filterable: view by date range, by area, by project, by label
7. Calculations update in real-time as new Deep Work sessions are logged
8. Export functionality allows downloading time allocation report as CSV for client invoicing or personal analysis

## Tasks / Subtasks
- [ ] Task 1: Create deep_work_sessions database table (AC: 1, 2)
  - [ ] Create deep_work_sessions table with columns: id, user_id, business_id, life_area_id, project_id, task_id, labels (TEXT[]), start_time, end_time, duration_minutes, notes
  - [ ] Add CHECK constraint: EITHER business_id OR life_area_id must be set (not both, not neither)
  - [ ] Add computed column: duration_hours as (duration_minutes / 60.0)
  - [ ] Create indexes: idx_deep_work_user_id, idx_deep_work_business_id, idx_deep_work_life_area_id, idx_deep_work_start_time
  - [ ] Add composite index for aggregation queries: idx_deep_work_user_date ON deep_work_sessions(user_id, DATE(start_time))
  - [ ] Enable RLS policies: users can only view/insert/update/delete their own sessions
  - [ ] Add foreign key constraints with ON DELETE SET NULL for referential integrity
  - [ ] Create TypeScript DeepWorkSession type matching schema
- [ ] Task 2: Build time allocation aggregation queries (AC: 2, 3)
  - [ ] Create SQL function: calculate_daily_allocation(user_id, date) returns JSONB with hours per business/life area
  - [ ] Create SQL function: calculate_weekly_allocation(user_id, week_start_date) returns hours by business across 7 days
  - [ ] Create SQL function: calculate_monthly_allocation(user_id, month_start_date) returns 30-day trend data
  - [ ] Aggregation formula: SUM(duration_minutes) / 60.0 GROUP BY business_id OR life_area_id
  - [ ] Handle NULL business_id/life_area_id as "Unallocated" category
  - [ ] Optimize with materialized views for historical data (refresh nightly)
  - [ ] Add COALESCE to join with businesses/life_areas tables for name resolution
- [ ] Task 3: Create useDeepWorkSessions React Query hook (AC: 7)
  - [ ] Create src/hooks/useDeepWorkSessions.ts with CRUD operations
  - [ ] Query: useDeepWorkSessions(filters: { dateRange, businessId, projectId, labels })
  - [ ] Mutation: useCreateDeepWorkSession with optimistic updates
  - [ ] Mutation: useUpdateDeepWorkSession for editing past sessions
  - [ ] Mutation: useDeleteDeepWorkSession for corrections
  - [ ] Real-time subscription via useRealtimeSync to update across tabs
  - [ ] Cache invalidation: refetch time allocation queries when sessions change
- [ ] Task 4: Build daily time allocation summary component (AC: 3, 4)
  - [ ] Create src/components/analytics/DailyTimeAllocation.tsx
  - [ ] Display: "Today: 3h Full Stack, 2h Huge Capital, 1h Health" as card summary
  - [ ] Use color-coded chips matching business/life area colors
  - [ ] Show total deep work hours today vs. yesterday comparison
  - [ ] Display unallocated time prominently if >0: "⚠️ 2h unallocated"
  - [ ] Click business chip → filter to show sessions for that business
  - [ ] Integrate into Daily page header below date
- [ ] Task 5: Build weekly time allocation bar chart (AC: 3)
  - [ ] Create src/components/analytics/WeeklyTimeChart.tsx using Recharts
  - [ ] Bar chart: X-axis = days (Mon-Sun), Y-axis = hours
  - [ ] Stacked bars: each business/life area as colored segment
  - [ ] Tooltip shows exact hours per business on hover
  - [ ] Legend toggles visibility of each business
  - [ ] Responsive design: collapses to horizontal scroll on mobile
  - [ ] Integration point: Time Analytics page or Dashboard widget
- [ ] Task 6: Build monthly time allocation trend line (AC: 3)
  - [ ] Create src/components/analytics/MonthlyTimeTrend.tsx using Recharts
  - [ ] Line chart: X-axis = dates (last 30 days), Y-axis = hours
  - [ ] Multiple lines: one per business/life area with distinct colors
  - [ ] Area chart variation: stacked areas showing proportion of total time
  - [ ] Dots on lines mark actual Deep Work session days
  - [ ] Zoom/pan functionality for detailed inspection
  - [ ] Export chart as PNG or SVG for reports
- [ ] Task 7: Implement label-based filtering system (AC: 1, 6)
  - [ ] Labels stored as TEXT[] array in deep_work_sessions table
  - [ ] Create LabelSelector component with autocomplete (suggests existing labels)
  - [ ] Common labels: "Internal Build", "$$$ Printer $$$", "Client Meeting", "Bug Fix", "New Feature"
  - [ ] Filter UI: multi-select dropdown for labels
  - [ ] Query: WHERE labels && ARRAY['Internal Build'] for label filtering
  - [ ] Label analytics: aggregate time spent per label across all businesses
  - [ ] Color-code labels: revenue-generating ($$$) vs. internal vs. maintenance
- [ ] Task 8: Build time allocation export functionality (AC: 8)
  - [ ] Create src/utils/exportTimeAllocation.ts utility
  - [ ] CSV format: Date, Business/Life Area, Project, Task, Labels, Duration (hours), Notes
  - [ ] Include date range filter: export last week, last month, custom range
  - [ ] Include business filter: export only Full Stack AI hours for client invoice
  - [ ] Add summary row: Total Hours = SUM(duration_hours)
  - [ ] Download as "time-allocation-YYYY-MM-DD.csv"
  - [ ] Optional PDF export using jsPDF for formatted invoices
  - [ ] Export button prominently placed on Analytics dashboard
- [ ] Task 9: Create Deep Work timer integration component (AC: 1)
  - [ ] Create src/components/deep-work/DeepWorkTimer.tsx
  - [ ] Timer UI: Start button → select Business/Life Area → select Project → select Task
  - [ ] Running timer: show elapsed time, pause/resume, stop buttons
  - [ ] On stop: prompt for Labels and Notes before saving session
  - [ ] Automatically calculate duration_minutes from start_time to end_time
  - [ ] Save session to deep_work_sessions table via useCreateDeepWorkSession
  - [ ] Show notification: "3.5h session logged to Full Stack AI"
  - [ ] Quick-restart: "Start another session on Full Stack AI?"
- [ ] Task 10: Implement real-time time allocation updates (AC: 7)
  - [ ] Extend useRealtimeSync hook to subscribe to deep_work_sessions table
  - [ ] On INSERT: invalidate daily/weekly/monthly allocation query cache
  - [ ] On UPDATE: invalidate affected date range queries
  - [ ] On DELETE: invalidate and refetch to ensure accuracy
  - [ ] Test: start session in Tab 1 → verify daily summary updates in Tab 2 within 500ms
  - [ ] Optimistic updates: increment daily total immediately, rollback on error
  - [ ] Background refetch: update aggregations every 60s if timer running

## Dev Notes

### Previous Story Insights
**From Epic 1 Stories:** [Source: docs/stories/1.1-1.6]
- Tasks table already includes business_id, project_id, phase_id, life_area_id foreign keys
- Real-time sync infrastructure via useRealtimeSync.ts is operational
- Bidirectional sync between Tasks Hub and Business/Daily/Life pages established
- Optimistic update patterns proven for <500ms perceived latency

**From Epic 2 Stories:** [Source: docs/stories/2.1-2.6]
- Progress calculation patterns established for tasks, phases, projects
- Aggregation queries optimized with indexes
- Review dashboard patterns for displaying multi-level rollups
- Visual progress indicators (rings, bars, percentages) implemented

**From Epic 3 Stories:** [Source: docs/stories/3.1-3.6]
- RLS policies required on all new tables (deep_work_sessions)
- Security checklist must include time data encryption
- Client financial data (billable hours) requires special protection
- Audit logging for time entries if used for invoicing

**Key Technical Context:**
- This is the FIRST story in Epic 4 - establishes foundation for all time analytics
- Deep Work sessions are the atomic unit of time tracking
- Each session MUST link to either a business OR a life area (not both, not neither)
- Labels provide cross-cutting categorization (e.g., "$$$ Printer $$$" spans multiple businesses)
- Aggregation queries will be called frequently - optimization critical

### Architecture Context

**Tech Stack:** [Source: docs/ui-architecture/2-frontend-tech-stack.md]
- React 19.1.1 + TypeScript 5.9.3
- TanStack Query 5.90.2 for state management
- Recharts for data visualization (recommended for React compatibility)
- date-fns 4.1.0 for date calculations
- Supabase JS 2.58.0 for real-time subscriptions

**Database Schema: deep_work_sessions Table**
```sql
CREATE TABLE deep_work_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Relationships (mutually exclusive: business XOR life_area)
  business_id UUID REFERENCES businesses(id) ON DELETE SET NULL,
  life_area_id UUID REFERENCES life_areas(id) ON DELETE SET NULL,
  project_id UUID REFERENCES projects(id) ON DELETE SET NULL,
  task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,

  -- Session details
  labels TEXT[] DEFAULT '{}',
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  duration_minutes INTEGER GENERATED ALWAYS AS (
    EXTRACT(EPOCH FROM (end_time - start_time)) / 60
  ) STORED,
  notes TEXT,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Constraints
  CONSTRAINT check_business_or_life_area CHECK (
    (business_id IS NOT NULL AND life_area_id IS NULL) OR
    (business_id IS NULL AND life_area_id IS NOT NULL)
  ),
  CONSTRAINT check_end_after_start CHECK (end_time > start_time)
);

-- Indexes for performance
CREATE INDEX idx_deep_work_user_id ON deep_work_sessions(user_id);
CREATE INDEX idx_deep_work_business_id ON deep_work_sessions(business_id);
CREATE INDEX idx_deep_work_life_area_id ON deep_work_sessions(life_area_id);
CREATE INDEX idx_deep_work_start_time ON deep_work_sessions(start_time);
CREATE INDEX idx_deep_work_labels ON deep_work_sessions USING GIN(labels);

-- Composite index for aggregation queries
CREATE INDEX idx_deep_work_user_date ON deep_work_sessions(
  user_id,
  DATE(start_time)
);

-- Enable RLS
ALTER TABLE deep_work_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own sessions"
  ON deep_work_sessions FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own sessions"
  ON deep_work_sessions FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own sessions"
  ON deep_work_sessions FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own sessions"
  ON deep_work_sessions FOR DELETE
  USING (auth.uid() = user_id);
```

**Time Allocation Aggregation Queries**
```sql
-- Daily allocation
CREATE OR REPLACE FUNCTION calculate_daily_allocation(
  p_user_id UUID,
  p_date DATE
)
RETURNS JSONB AS $$
  SELECT jsonb_object_agg(
    COALESCE(b.name, la.name, 'Unallocated'),
    ROUND(SUM(dws.duration_minutes) / 60.0, 2)
  )
  FROM deep_work_sessions dws
  LEFT JOIN businesses b ON dws.business_id = b.id
  LEFT JOIN life_areas la ON dws.life_area_id = la.id
  WHERE dws.user_id = p_user_id
    AND DATE(dws.start_time) = p_date
  GROUP BY COALESCE(b.name, la.name, 'Unallocated');
$$ LANGUAGE SQL STABLE;

-- Weekly allocation (7 days, grouped by business)
CREATE OR REPLACE FUNCTION calculate_weekly_allocation(
  p_user_id UUID,
  p_week_start DATE
)
RETURNS TABLE(
  day_date DATE,
  business_name TEXT,
  hours NUMERIC
) AS $$
  SELECT
    DATE(dws.start_time) as day_date,
    COALESCE(b.name, la.name, 'Unallocated') as business_name,
    ROUND(SUM(dws.duration_minutes) / 60.0, 2) as hours
  FROM deep_work_sessions dws
  LEFT JOIN businesses b ON dws.business_id = b.id
  LEFT JOIN life_areas la ON dws.life_area_id = la.id
  WHERE dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_week_start
    AND DATE(dws.start_time) < p_week_start + INTERVAL '7 days'
  GROUP BY DATE(dws.start_time), COALESCE(b.name, la.name, 'Unallocated')
  ORDER BY day_date, business_name;
$$ LANGUAGE SQL STABLE;

-- Monthly trend (30 days)
CREATE OR REPLACE FUNCTION calculate_monthly_allocation(
  p_user_id UUID,
  p_month_start DATE
)
RETURNS TABLE(
  day_date DATE,
  business_name TEXT,
  hours NUMERIC
) AS $$
  SELECT
    DATE(dws.start_time) as day_date,
    COALESCE(b.name, la.name, 'Unallocated') as business_name,
    ROUND(SUM(dws.duration_minutes) / 60.0, 2) as hours
  FROM deep_work_sessions dws
  LEFT JOIN businesses b ON dws.business_id = b.id
  LEFT JOIN life_areas la ON dws.life_area_id = la.id
  WHERE dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_month_start
    AND DATE(dws.start_time) < p_month_start + INTERVAL '30 days'
  GROUP BY DATE(dws.start_time), COALESCE(b.name, la.name, 'Unallocated')
  ORDER BY day_date, business_name;
$$ LANGUAGE SQL STABLE;
```

**React Query Hook Pattern**
```typescript
// src/hooks/useDeepWorkSessions.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase';
import type { DeepWorkSession } from '@/types/deepWork';

interface TimeAllocationFilters {
  dateRange?: { start: Date; end: Date };
  businessId?: string;
  lifeAreaId?: string;
  projectId?: string;
  labels?: string[];
}

export const useDeepWorkSessions = (filters: TimeAllocationFilters = {}) => {
  return useQuery({
    queryKey: ['deep-work-sessions', filters],
    queryFn: async () => {
      let query = supabase
        .from('deep_work_sessions')
        .select(`
          *,
          business:businesses(id, name, color),
          life_area:life_areas(id, name, color),
          project:projects(id, name),
          task:tasks(id, task_name)
        `)
        .order('start_time', { ascending: false });

      if (filters.dateRange) {
        query = query
          .gte('start_time', filters.dateRange.start.toISOString())
          .lte('start_time', filters.dateRange.end.toISOString());
      }

      if (filters.businessId) {
        query = query.eq('business_id', filters.businessId);
      }

      if (filters.lifeAreaId) {
        query = query.eq('life_area_id', filters.lifeAreaId);
      }

      if (filters.projectId) {
        query = query.eq('project_id', filters.projectId);
      }

      if (filters.labels && filters.labels.length > 0) {
        query = query.overlaps('labels', filters.labels);
      }

      const { data, error } = await query;

      if (error) throw error;
      return data as DeepWorkSession[];
    },
  });
};

export const useCreateDeepWorkSession = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (session: Omit<DeepWorkSession, 'id' | 'created_at' | 'updated_at'>) => {
      const { data, error } = await supabase
        .from('deep_work_sessions')
        .insert(session)
        .select()
        .single();

      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      // Invalidate all time allocation queries
      queryClient.invalidateQueries({ queryKey: ['deep-work-sessions'] });
      queryClient.invalidateQueries({ queryKey: ['time-allocation'] });
    },
  });
};

export const useDailyTimeAllocation = (date: Date) => {
  return useQuery({
    queryKey: ['time-allocation', 'daily', date.toISOString()],
    queryFn: async () => {
      const { data, error } = await supabase.rpc('calculate_daily_allocation', {
        p_user_id: (await supabase.auth.getUser()).data.user?.id,
        p_date: date.toISOString().split('T')[0],
      });

      if (error) throw error;
      return data as Record<string, number>;
    },
  });
};
```

**Recharts Integration Pattern**
```typescript
// src/components/analytics/WeeklyTimeChart.tsx
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { useWeeklyTimeAllocation } from '@/hooks/useTimeAllocation';
import { startOfWeek } from 'date-fns';

export const WeeklyTimeChart = () => {
  const weekStart = startOfWeek(new Date(), { weekStartsOn: 1 }); // Monday
  const { data: weeklyData, isLoading } = useWeeklyTimeAllocation(weekStart);

  if (isLoading) return <div>Loading chart...</div>;

  // Transform data for Recharts
  const chartData = transformToChartData(weeklyData);

  return (
    <ResponsiveContainer width="100%" height={400}>
      <BarChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="day" />
        <YAxis label={{ value: 'Hours', angle: -90, position: 'insideLeft' }} />
        <Tooltip />
        <Legend />
        <Bar dataKey="Full Stack AI" stackId="a" fill="#3b82f6" />
        <Bar dataKey="Huge Capital" stackId="a" fill="#10b981" />
        <Bar dataKey="S4" stackId="a" fill="#f59e0b" />
        <Bar dataKey="808" stackId="a" fill="#ec4899" />
        <Bar dataKey="Service SaaS" stackId="a" fill="#8b5cf6" />
        <Bar dataKey="Health" stackId="a" fill="#ef4444" />
      </BarChart>
    </ResponsiveContainer>
  );
};
```

**CSV Export Utility Pattern**
```typescript
// src/utils/exportTimeAllocation.ts
import { format } from 'date-fns';

export const exportTimeAllocationCSV = (
  sessions: DeepWorkSession[],
  filename?: string
) => {
  const headers = ['Date', 'Business/Life Area', 'Project', 'Task', 'Labels', 'Hours', 'Notes'];

  const rows = sessions.map(session => [
    format(new Date(session.start_time), 'yyyy-MM-dd'),
    session.business?.name || session.life_area?.name || 'Unallocated',
    session.project?.name || '-',
    session.task?.task_name || '-',
    session.labels.join(', '),
    (session.duration_minutes / 60).toFixed(2),
    session.notes || '',
  ]);

  // Add summary row
  const totalHours = sessions.reduce((sum, s) => sum + s.duration_minutes / 60, 0);
  rows.push(['', '', '', '', 'TOTAL', totalHours.toFixed(2), '']);

  const csvContent = [
    headers.join(','),
    ...rows.map(row => row.map(cell => `"${cell}"`).join(',')),
  ].join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename || `time-allocation-${format(new Date(), 'yyyy-MM-dd')}.csv`;
  link.click();
};
```

**File Locations:**
- Create: supabase-deep-work-sessions-schema.sql (database schema)
- Create: src/types/deepWork.ts (TypeScript types)
- Create: src/hooks/useDeepWorkSessions.ts (React Query hooks)
- Create: src/hooks/useTimeAllocation.ts (aggregation query hooks)
- Create: src/components/deep-work/DeepWorkTimer.tsx (timer component)
- Create: src/components/analytics/DailyTimeAllocation.tsx (daily summary)
- Create: src/components/analytics/WeeklyTimeChart.tsx (bar chart)
- Create: src/components/analytics/MonthlyTimeTrend.tsx (line chart)
- Create: src/components/shared/LabelSelector.tsx (label input)
- Create: src/utils/exportTimeAllocation.ts (CSV export)

### Testing

**Testing Requirements:** [Source: docs/prd/technical-assumptions.md]
Manual testing with systematic verification (no automated test suite per PRD)

**Time Allocation Validation Workflow:**
1. **Database Schema Verification:**
   - Run schema SQL in Supabase SQL Editor
   - Verify deep_work_sessions table created with all columns
   - Test CHECK constraint: try inserting session with both business_id and life_area_id → verify fails
   - Test CHECK constraint: try end_time < start_time → verify fails
   - Verify RLS policies: create session as user A, try to query as user B → verify blocked

2. **Deep Work Session CRUD Testing:**
   - Create session: Start timer → select Full Stack AI → stop after 30 min → verify saved with duration_minutes = 30
   - Update session: Edit past session → change business from Full Stack to Huge Capital → verify updated
   - Delete session: Delete test session → verify removed from database and daily total updated
   - Test with labels: Add session with labels ["$$$ Printer $$$", "Client Meeting"] → verify stored as array

3. **Daily Time Allocation Testing:**
   - Create 3 sessions today: 2h Full Stack, 1.5h Huge Capital, 1h Health
   - Verify daily summary shows: "Full Stack AI: 2h, Huge Capital: 1.5h, Health: 1h"
   - Verify color-coded chips match business colors
   - Verify total: 4.5h deep work today
   - Create session without business/life area → verify shows as "Unallocated"

4. **Weekly Chart Testing:**
   - Create sessions across Mon-Fri with varying businesses
   - Verify WeeklyTimeChart renders stacked bar chart
   - Hover over bar → verify tooltip shows exact hours per business
   - Click legend to toggle business visibility → verify bars update
   - Verify responsive design: resize to mobile width → verify chart scrolls horizontally

5. **Monthly Trend Testing:**
   - Create sessions across 30 days with varying time allocation
   - Verify MonthlyTimeTrend renders line chart with multiple business lines
   - Verify days without sessions show gaps (not zero)
   - Test zoom: select date range within month → verify chart zooms
   - Export chart as PNG → verify downloads correctly

6. **Label Filtering Testing:**
   - Create sessions with various labels: "Internal Build", "$$$ Printer $$$", "Bug Fix"
   - Filter by "$$$ Printer $$$" → verify only revenue-generating sessions shown
   - Filter by multiple labels → verify AND logic (sessions with all labels)
   - Verify autocomplete suggests existing labels when typing
   - Test label analytics: verify total hours per label calculated correctly

7. **CSV Export Testing:**
   - Export last week's time allocation
   - Verify CSV contains all columns: Date, Business/Life Area, Project, Task, Labels, Hours, Notes
   - Verify summary row with total hours matches UI total
   - Export with business filter: Full Stack AI only → verify only those sessions in CSV
   - Open CSV in Excel → verify proper formatting and no encoding issues

8. **Real-Time Sync Testing:**
   - Open dashboard in Tab 1 and Tab 2
   - Start Deep Work session in Tab 1 → verify timer appears in both tabs within 500ms
   - Stop session in Tab 1 → verify daily total updates in Tab 2 within 500ms
   - Edit past session in Tab 1 → verify weekly chart updates in Tab 2
   - Delete session in Tab 1 → verify removed from Tab 2 immediately

9. **Performance Testing:**
   - Create 100 Deep Work sessions across 30 days
   - Verify monthly trend query executes <100ms
   - Verify daily allocation calculates <50ms
   - Check database query plan: verify indexes used for aggregations
   - Test CSV export with 500 sessions → verify completes <2s

10. **Integration Testing:**
    - Link Deep Work session to specific Task
    - Verify task_id foreign key enforced
    - Delete task → verify Deep Work session sets task_id to NULL (not deleted)
    - Verify task shows "3.5h logged" based on linked Deep Work sessions
    - Create session for Business → verify appears on Business page time investment card

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
