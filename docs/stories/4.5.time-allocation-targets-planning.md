# Story 4.5: Time Allocation Targets & Planning

## Status
Draft

## Story
**As a** strategic operator,
**I want** to set time allocation targets for each business and life area,
**so that** I can proactively plan balanced attention rather than reactively discovering imbalances.

## Acceptance Criteria
1. Settings page allows defining weekly time targets for each business: "Full Stack: 10h, Huge Capital: 8h, S4: 6h, 808: 4h, Service SaaS: 5h"
2. Settings page allows defining life area time targets: "Health: 5h, Content: 3h, Golf: 2h, Personal: 5h"
3. Dashboard displays "Planned vs. Actual" comparison: visual bars showing target hours vs. actual hours logged
4. Weekly planning view shows time budget allocation: "You have 40h available this week, allocated 33h, 7h unallocated"
5. Over-allocation warning: if targets exceed realistic capacity (e.g., 60h/week), display warning: "⚠️ Target allocation exceeds sustainable capacity"
6. Target adjustment recommendations: "You're consistently spending 12h on Huge Capital but target is 8h - update target?"
7. Monthly target review: end-of-month summary shows adherence to targets with suggestions for next month
8. Targets can be adjusted dynamically: "This week, increase Huge Capital to 12h due to urgent project" (temporary override)
9. Time allocation forecast: based on current Deep Work sessions logged, predict if weekly targets will be met

## Tasks / Subtasks
- [ ] Task 1: Add time target columns to businesses and life_areas tables (AC: 1, 2)
  - [ ] Add time_target_hours_per_week column to businesses table (INTEGER, nullable, default NULL)
  - [ ] Add time_target_hours_per_week column to life_areas table (already exists from Story 4.3)
  - [ ] Create TypeScript TimeTarget type: { id, name, target_hours, actual_hours, percentage }
  - [ ] Create migration script: alter-tables-add-time-targets.sql
  - [ ] Add CHECK constraint: target_hours >= 0 AND target_hours <= 168 (max hours in week)
  - [ ] Create indexes: idx_businesses_time_target, idx_life_areas_time_target
  - [ ] Update useBusinesses and useLifeAreas hooks to include target fields
- [ ] Task 2: Build Time Targets Settings page (AC: 1, 2)
  - [ ] Create src/pages/TimeTargetsSettings.tsx (route: /settings/time-targets)
  - [ ] Add navigation link in Settings menu: "Time Allocation Targets"
  - [ ] Layout: Two sections - "Business Targets" and "Life Area Targets"
  - [ ] Each section: List of businesses/life areas with editable target input (hours per week)
  - [ ] Input validation: Must be 0-168 hours, numeric only
  - [ ] Save button: Update businesses.time_target_hours_per_week or life_areas.time_target_hours_per_week
  - [ ] Show current actual hours next to target for reference: "Full Stack AI: Target 10h (Current: 12h this week)"
  - [ ] Quick presets: "Work Week (40h)", "Part Time (20h)", "Full Time (50h)" to distribute across businesses
  - [ ] Reset button: Clear all targets (set to NULL)
- [ ] Task 3: Create Planned vs. Actual comparison dashboard (AC: 3)
  - [ ] Create src/components/planning/PlannedVsActualDashboard.tsx
  - [ ] Query: Get all businesses + life areas with targets, join with actual hours this week
  - [ ] Horizontal bar chart: Each business/life area as row
  - [ ] Two bars per row: Target (light color) and Actual (solid color) side by side
  - [ ] Color logic: Actual >= Target (green), Actual 80-99% of Target (yellow), Actual < 80% (red)
  - [ ] Delta indicator: "+2h" or "-3h" next to actual bar
  - [ ] Percentage: "120% of target" or "75% of target"
  - [ ] Tooltip: Shows exact target hours, actual hours, and delta
  - [ ] Integration: Dashboard home page or dedicated Planning page
- [ ] Task 4: Build weekly time budget allocation view (AC: 4)
  - [ ] Create src/components/planning/WeeklyTimeBudget.tsx
  - [ ] Calculate total available hours: Default 40h work week (configurable in settings)
  - [ ] Sum all targets: business_targets + life_area_targets
  - [ ] Display: "Total Available: 40h, Allocated: 33h, Unallocated: 7h"
  - [ ] Visual: Stacked horizontal progress bar showing allocation
  - [ ] Segments: Each business/life area as colored segment proportional to target
  - [ ] Unallocated segment: Gray segment for remaining hours
  - [ ] Warning if allocated = 0: "⚠️ No targets set - click 'Set Targets' to plan your week"
  - [ ] Integration: Top of Planning page or Dashboard widget
- [ ] Task 5: Implement over-allocation warning system (AC: 5)
  - [ ] Create src/components/planning/OverAllocationWarning.tsx
  - [ ] Calculate total targets: SUM(businesses.time_target + life_areas.time_target)
  - [ ] Get available hours from settings (default 40h, configurable to 50h, 60h, etc.)
  - [ ] Logic: If total_targets > available_hours, show warning
  - [ ] Warning levels: >120% = red alert, 100-120% = yellow warning, <100% = none
  - [ ] Message: "⚠️ Target allocation exceeds sustainable capacity (60h planned, 40h available)"
  - [ ] Recommendation: "Consider reducing targets or increasing available work hours in settings"
  - [ ] CTA button: "Adjust Targets" → navigate to Time Targets Settings page
  - [ ] Integration: Shows prominently on Planning page and Dashboard if over-allocated
- [ ] Task 6: Create target adjustment recommendation system (AC: 6)
  - [ ] Create SQL function: detect_target_mismatches(user_id) returns JSONB array of recommendations
  - [ ] Logic: Compare last 4 weeks average actual hours vs. target for each business/life area
  - [ ] Mismatch types:
    - Consistent over: Actual > Target + 20% for 3+ weeks → "Consider increasing target"
    - Consistent under: Actual < Target - 20% for 3+ weeks → "Consider decreasing target"
    - Perfect match: Actual within ±10% of Target → "Target well-calibrated"
  - [ ] Create src/components/planning/TargetRecommendations.tsx
  - [ ] Display: List of recommendations with action buttons
  - [ ] Example: "Huge Capital: Averaging 12h/week but target is 8h - Update target to 12h?"
  - [ ] Action buttons: "Update Target" (apply recommendation), "Dismiss" (ignore)
  - [ ] Track dismissed recommendations in localStorage (don't repeat for 30 days)
  - [ ] Integration: Planning page expandable section "Target Adjustment Suggestions"
- [ ] Task 7: Build monthly target review summary (AC: 7)
  - [ ] Create src/components/planning/MonthlyTargetReview.tsx
  - [ ] Query: Get last month's actual hours per business/life area, compare to targets
  - [ ] Calculate adherence: (weeks_met_target / total_weeks) * 100
  - [ ] Display: "August 2025 Target Review"
  - [ ] Table: Business/Life Area | Target | Actual | Adherence % | Status
  - [ ] Status: ✅ Met Target (>=100%), ⚠️ Close (80-99%), ❌ Missed (<80%)
  - [ ] Summary: "You met targets for 3/5 businesses and 2/4 life areas this month"
  - [ ] Insights: "Health target missed by 40% - consider prioritizing in September"
  - [ ] Suggestions for next month: "Increase Health target to 6h to account for seasonal goals"
  - [ ] Export as PDF: Monthly review report for personal records
  - [ ] Integration: Triggered automatically on 1st of each month, accessible from Planning page
- [ ] Task 8: Implement dynamic temporary target overrides (AC: 8)
  - [ ] Add temporary_target_override column to businesses and life_areas tables (INTEGER, nullable)
  - [ ] Add override_start_date and override_end_date columns (DATE, nullable)
  - [ ] Create src/components/planning/TemporaryTargetOverride.tsx modal
  - [ ] UI: Select business/life area, enter temporary target hours, select date range (this week, next week, custom)
  - [ ] Save: Update temporary_target_override, override_start_date, override_end_date
  - [ ] Query logic: Use temporary_target if current_date between override_start and override_end, else use regular target
  - [ ] Display: Show badge on business/life area: "Temporary: 12h this week (normal: 8h)"
  - [ ] Auto-expire: On override_end_date + 1, set temporary_target_override to NULL
  - [ ] Use case: "Huge Capital urgent project this week → override to 15h"
  - [ ] Integration: "Set Temporary Override" button on PlannedVsActualDashboard
- [ ] Task 9: Create time allocation forecast system (AC: 9)
  - [ ] Create SQL function: forecast_weekly_targets(user_id, week_start_date) returns JSONB
  - [ ] Logic: Based on current actual hours (Mon-Thu), predict if weekly targets will be met
  - [ ] Formula: projected_weekly_hours = (actual_hours_so_far / days_elapsed) * 7
  - [ ] Forecast status: "On Track" (projected >= target), "At Risk" (projected 80-99%), "Unlikely" (projected < 80%)
  - [ ] Create src/components/planning/WeeklyForecast.tsx
  - [ ] Display: "Week Forecast (as of Thursday)"
  - [ ] Table: Business | Target | Actual So Far | Projected | Status
  - [ ] Example: "Full Stack AI: 10h target, 6h so far, projected 10.5h → ✅ On Track"
  - [ ] Alert: "⚠️ Health at risk: 1h so far, projected 1.75h (target 5h) - schedule time this weekend"
  - [ ] CTA: "Schedule Catch-Up Time" button → opens Daily page to add sessions
  - [ ] Integration: Shows mid-week (Wed-Fri) on Dashboard and Planning page
- [ ] Task 10: Build comprehensive Planning page with all components (AC: all)
  - [ ] Create src/pages/Planning.tsx (route: /planning)
  - [ ] Add navigation link: "Planning" in main navigation with calendar icon
  - [ ] Page layout:
    - Section 1: WeeklyTimeBudget (hero - shows allocation overview)
    - Section 2: WeeklyForecast (if mid-week) or WeeklyPlanning (if weekend/Monday)
    - Section 3: PlannedVsActualDashboard (full-width comparison)
    - Section 4: OverAllocationWarning (if applicable - alert)
    - Section 5: TargetRecommendations (expandable - suggestions)
    - Section 6: MonthlyTargetReview (at month-end or accessible via tab)
  - [ ] Header actions: "Set Targets", "Add Temporary Override", "Export Plan"
  - [ ] Tab navigation: "This Week" | "This Month" | "Target Settings"
  - [ ] Real-time updates: Planning data refreshes when Deep Work sessions logged
  - [ ] Help tooltip: Explain target planning workflow for first-time users

## Dev Notes

### Previous Story Insights
**From Story 4.1:** [Source: docs/stories/4.1.deep-work-time-allocation-calculation.md]
- deep_work_sessions table with business_id, life_area_id, start_time, duration_minutes
- Time aggregation SQL functions for daily, weekly, monthly calculations
- Real-time sync infrastructure via useRealtimeSync

**From Story 4.2:** [Source: docs/stories/4.2.business-time-investment-dashboard.md]
- time_budget_hours_per_week column added to businesses table for targets
- TimeBudgetIndicator component pattern: target vs. actual with progress bar
- Business comparison view showing relative time investment

**From Story 4.3:** [Source: docs/stories/4.3.health-goal-time-monitoring.md]
- time_target_hours_per_week and time_target_minutes_per_day added to life_areas table
- Target vs. actual comparison patterns with color-coded indicators
- Warning systems for target misses

**From Story 4.4:** [Source: docs/stories/4.4.time-allocation-visual-analytics.md]
- Time Analytics dashboard with comprehensive visualizations
- Date range selector patterns
- Recharts integration for bar charts, pie charts, line graphs

**Key Technical Context:**
- This is the FIFTH story in Epic 4 - adds proactive planning layer on top of reactive tracking
- Targets enable proactive time management vs. reactive time discovery
- Temporary overrides allow flexibility for urgent projects without permanently changing targets
- Forecasting helps mid-week course correction before targets are missed
- Over-allocation warnings prevent burnout from unrealistic target setting

### Architecture Context

**Tech Stack:** [Source: docs/ui-architecture/2-frontend-tech-stack.md]
- React 19.1.1 + TypeScript 5.9.3
- TanStack Query 5.90.2 for target data fetching and caching
- Recharts for planned vs. actual visualizations
- date-fns 4.1.0 for date calculations
- Lucide React 0.544.0 for icons (Calendar, AlertTriangle, Target)

**Database Schema Updates**
```sql
-- Add time target columns to businesses table (if not exists from Story 4.2)
ALTER TABLE businesses ADD COLUMN IF NOT EXISTS time_target_hours_per_week INTEGER DEFAULT NULL
  CHECK (time_target_hours_per_week >= 0 AND time_target_hours_per_week <= 168);

-- Add temporary override columns to businesses
ALTER TABLE businesses ADD COLUMN temporary_target_override INTEGER DEFAULT NULL
  CHECK (temporary_target_override >= 0 AND temporary_target_override <= 168);
ALTER TABLE businesses ADD COLUMN override_start_date DATE DEFAULT NULL;
ALTER TABLE businesses ADD COLUMN override_end_date DATE DEFAULT NULL;

-- Add temporary override columns to life_areas
ALTER TABLE life_areas ADD COLUMN temporary_target_override INTEGER DEFAULT NULL
  CHECK (temporary_target_override >= 0 AND temporary_target_override <= 168);
ALTER TABLE life_areas ADD COLUMN override_start_date DATE DEFAULT NULL;
ALTER TABLE life_areas ADD COLUMN override_end_date DATE DEFAULT NULL;

-- Create indexes for target queries
CREATE INDEX IF NOT EXISTS idx_businesses_time_target ON businesses(time_target_hours_per_week);
CREATE INDEX IF NOT EXISTS idx_life_areas_time_target ON life_areas(time_target_hours_per_week);
CREATE INDEX IF NOT EXISTS idx_businesses_override_dates ON businesses(override_start_date, override_end_date);
CREATE INDEX IF NOT EXISTS idx_life_areas_override_dates ON life_areas(override_start_date, override_end_date);

-- User settings table for available work hours
CREATE TABLE IF NOT EXISTS user_settings (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  available_work_hours_per_week INTEGER DEFAULT 40 CHECK (available_work_hours_per_week > 0 AND available_work_hours_per_week <= 168),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS on user_settings
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own settings"
  ON user_settings FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own settings"
  ON user_settings FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own settings"
  ON user_settings FOR INSERT
  WITH CHECK (auth.uid() = user_id);
```

**Target Management SQL Functions**
```sql
-- Get effective target (considering temporary overrides)
CREATE OR REPLACE FUNCTION get_effective_target(
  p_regular_target INTEGER,
  p_temporary_override INTEGER,
  p_override_start DATE,
  p_override_end DATE
)
RETURNS INTEGER AS $$
BEGIN
  IF p_temporary_override IS NOT NULL
     AND p_override_start IS NOT NULL
     AND p_override_end IS NOT NULL
     AND CURRENT_DATE >= p_override_start
     AND CURRENT_DATE <= p_override_end THEN
    RETURN p_temporary_override;
  ELSE
    RETURN p_regular_target;
  END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Get planned vs. actual for all businesses and life areas
CREATE OR REPLACE FUNCTION get_planned_vs_actual(
  p_user_id UUID,
  p_week_start DATE
)
RETURNS TABLE(
  type TEXT,
  id UUID,
  name TEXT,
  target_hours INTEGER,
  actual_hours NUMERIC,
  percentage NUMERIC,
  status TEXT
) AS $$
BEGIN
  RETURN QUERY
  -- Businesses
  SELECT
    'business'::TEXT as type,
    b.id,
    b.name,
    get_effective_target(
      b.time_target_hours_per_week,
      b.temporary_target_override,
      b.override_start_date,
      b.override_end_date
    ) as target_hours,
    COALESCE(ROUND(SUM(dws.duration_minutes) / 60.0, 2), 0) as actual_hours,
    CASE
      WHEN get_effective_target(
        b.time_target_hours_per_week,
        b.temporary_target_override,
        b.override_start_date,
        b.override_end_date
      ) > 0 THEN
        ROUND((SUM(dws.duration_minutes) / 60.0) / get_effective_target(
          b.time_target_hours_per_week,
          b.temporary_target_override,
          b.override_start_date,
          b.override_end_date
        ) * 100, 0)
      ELSE 0
    END as percentage,
    CASE
      WHEN get_effective_target(
        b.time_target_hours_per_week,
        b.temporary_target_override,
        b.override_start_date,
        b.override_end_date
      ) IS NULL THEN 'no_target'
      WHEN (SUM(dws.duration_minutes) / 60.0) >= get_effective_target(
        b.time_target_hours_per_week,
        b.temporary_target_override,
        b.override_start_date,
        b.override_end_date
      ) THEN 'on_track'
      WHEN (SUM(dws.duration_minutes) / 60.0) >= get_effective_target(
        b.time_target_hours_per_week,
        b.temporary_target_override,
        b.override_start_date,
        b.override_end_date
      ) * 0.8 THEN 'at_risk'
      ELSE 'behind'
    END as status
  FROM businesses b
  LEFT JOIN deep_work_sessions dws ON b.id = dws.business_id
    AND dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_week_start
    AND DATE(dws.start_time) < p_week_start + INTERVAL '7 days'
  WHERE b.user_id = p_user_id
  GROUP BY b.id, b.name, b.time_target_hours_per_week, b.temporary_target_override,
    b.override_start_date, b.override_end_date

  UNION ALL

  -- Life Areas
  SELECT
    'life_area'::TEXT as type,
    la.id,
    la.name,
    get_effective_target(
      la.time_target_hours_per_week,
      la.temporary_target_override,
      la.override_start_date,
      la.override_end_date
    ) as target_hours,
    COALESCE(ROUND(SUM(dws.duration_minutes) / 60.0, 2), 0) as actual_hours,
    CASE
      WHEN get_effective_target(
        la.time_target_hours_per_week,
        la.temporary_target_override,
        la.override_start_date,
        la.override_end_date
      ) > 0 THEN
        ROUND((SUM(dws.duration_minutes) / 60.0) / get_effective_target(
          la.time_target_hours_per_week,
          la.temporary_target_override,
          la.override_start_date,
          la.override_end_date
        ) * 100, 0)
      ELSE 0
    END as percentage,
    CASE
      WHEN get_effective_target(
        la.time_target_hours_per_week,
        la.temporary_target_override,
        la.override_start_date,
        la.override_end_date
      ) IS NULL THEN 'no_target'
      WHEN (SUM(dws.duration_minutes) / 60.0) >= get_effective_target(
        la.time_target_hours_per_week,
        la.temporary_target_override,
        la.override_start_date,
        la.override_end_date
      ) THEN 'on_track'
      WHEN (SUM(dws.duration_minutes) / 60.0) >= get_effective_target(
        la.time_target_hours_per_week,
        la.temporary_target_override,
        la.override_start_date,
        la.override_end_date
      ) * 0.8 THEN 'at_risk'
      ELSE 'behind'
    END as status
  FROM life_areas la
  LEFT JOIN deep_work_sessions dws ON la.id = dws.life_area_id
    AND dws.user_id = p_user_id
    AND DATE(dws.start_time) >= p_week_start
    AND DATE(dws.start_time) < p_week_start + INTERVAL '7 days'
  WHERE la.user_id = p_user_id
  GROUP BY la.id, la.name, la.time_target_hours_per_week, la.temporary_target_override,
    la.override_start_date, la.override_end_date;
END;
$$ LANGUAGE plpgsql STABLE;

-- Detect target mismatches (for recommendations)
CREATE OR REPLACE FUNCTION detect_target_mismatches(p_user_id UUID)
RETURNS JSONB AS $$
DECLARE
  v_recommendations JSONB := '[]'::JSONB;
  v_record RECORD;
  v_avg_actual NUMERIC;
  v_target INTEGER;
BEGIN
  -- Check businesses
  FOR v_record IN
    SELECT
      b.id,
      b.name,
      b.time_target_hours_per_week as target,
      AVG(weekly_hours.hours) as avg_actual
    FROM businesses b
    LEFT JOIN LATERAL (
      SELECT SUM(duration_minutes) / 60.0 as hours
      FROM deep_work_sessions
      WHERE business_id = b.id
        AND user_id = p_user_id
        AND start_time >= NOW() - INTERVAL '4 weeks'
      GROUP BY DATE_TRUNC('week', start_time)
    ) weekly_hours ON true
    WHERE b.user_id = p_user_id
      AND b.time_target_hours_per_week IS NOT NULL
    GROUP BY b.id, b.name, b.time_target_hours_per_week
    HAVING COUNT(weekly_hours.hours) >= 3
  LOOP
    v_avg_actual := COALESCE(v_record.avg_actual, 0);
    v_target := v_record.target;

    IF v_avg_actual > v_target * 1.2 THEN
      v_recommendations := v_recommendations || jsonb_build_object(
        'type', 'business',
        'id', v_record.id,
        'name', v_record.name,
        'current_target', v_target,
        'suggested_target', CEIL(v_avg_actual),
        'avg_actual', ROUND(v_avg_actual, 1),
        'reason', 'consistent_over',
        'message', format('Averaging %.1fh/week but target is %sh - consider increasing to %sh',
          v_avg_actual, v_target, CEIL(v_avg_actual))
      );
    ELSIF v_avg_actual < v_target * 0.8 THEN
      v_recommendations := v_recommendations || jsonb_build_object(
        'type', 'business',
        'id', v_record.id,
        'name', v_record.name,
        'current_target', v_target,
        'suggested_target', CEIL(v_avg_actual),
        'avg_actual', ROUND(v_avg_actual, 1),
        'reason', 'consistent_under',
        'message', format('Averaging %.1fh/week but target is %sh - consider decreasing to %sh',
          v_avg_actual, v_target, CEIL(v_avg_actual))
      );
    END IF;
  END LOOP;

  -- Similar logic for life_areas (omitted for brevity)

  RETURN v_recommendations;
END;
$$ LANGUAGE plpgsql STABLE;

-- Weekly forecast
CREATE OR REPLACE FUNCTION forecast_weekly_targets(
  p_user_id UUID,
  p_week_start DATE
)
RETURNS TABLE(
  type TEXT,
  id UUID,
  name TEXT,
  target_hours INTEGER,
  actual_hours NUMERIC,
  days_elapsed INTEGER,
  projected_hours NUMERIC,
  status TEXT
) AS $$
DECLARE
  v_days_elapsed INTEGER;
BEGIN
  v_days_elapsed := EXTRACT(DOW FROM CURRENT_DATE) - EXTRACT(DOW FROM p_week_start);
  IF v_days_elapsed <= 0 THEN
    v_days_elapsed := 1;
  END IF;

  RETURN QUERY
  SELECT
    pva.type,
    pva.id,
    pva.name,
    pva.target_hours,
    pva.actual_hours,
    v_days_elapsed,
    ROUND((pva.actual_hours / v_days_elapsed) * 7, 2) as projected_hours,
    CASE
      WHEN pva.target_hours IS NULL THEN 'no_target'
      WHEN (pva.actual_hours / v_days_elapsed) * 7 >= pva.target_hours THEN 'on_track'
      WHEN (pva.actual_hours / v_days_elapsed) * 7 >= pva.target_hours * 0.8 THEN 'at_risk'
      ELSE 'unlikely'
    END as status
  FROM get_planned_vs_actual(p_user_id, p_week_start) pva;
END;
$$ LANGUAGE plpgsql STABLE;
```

**React Query Hooks Pattern**
```typescript
// src/hooks/useTimePlanning.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase';
import { startOfWeek, format } from 'date-fns';

export const usePlannedVsActual = (weekStart: Date) => {
  return useQuery({
    queryKey: ['planned-vs-actual', format(weekStart, 'yyyy-MM-dd')],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('get_planned_vs_actual', {
        p_user_id: user.id,
        p_week_start: format(weekStart, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data as Array<{
        type: 'business' | 'life_area';
        id: string;
        name: string;
        target_hours: number;
        actual_hours: number;
        percentage: number;
        status: 'no_target' | 'on_track' | 'at_risk' | 'behind';
      }>;
    },
    refetchInterval: 60 * 1000, // Refetch every minute
  });
};

export const useWeeklyForecast = (weekStart: Date) => {
  return useQuery({
    queryKey: ['weekly-forecast', format(weekStart, 'yyyy-MM-dd')],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('forecast_weekly_targets', {
        p_user_id: user.id,
        p_week_start: format(weekStart, 'yyyy-MM-dd'),
      });

      if (error) throw error;
      return data;
    },
  });
};

export const useTargetRecommendations = () => {
  return useQuery({
    queryKey: ['target-recommendations'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase.rpc('detect_target_mismatches', {
        p_user_id: user.id,
      });

      if (error) throw error;
      return data as Array<{
        type: 'business' | 'life_area';
        id: string;
        name: string;
        current_target: number;
        suggested_target: number;
        avg_actual: number;
        reason: 'consistent_over' | 'consistent_under';
        message: string;
      }>;
    },
    staleTime: 60 * 60 * 1000, // 1 hour
  });
};

export const useUpdateTimeTarget = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      type,
      id,
      targetHours,
    }: {
      type: 'business' | 'life_area';
      id: string;
      targetHours: number | null;
    }) => {
      const table = type === 'business' ? 'businesses' : 'life_areas';
      const { error } = await supabase
        .from(table)
        .update({ time_target_hours_per_week: targetHours })
        .eq('id', id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['planned-vs-actual'] });
      queryClient.invalidateQueries({ queryKey: ['target-recommendations'] });
    },
  });
};

export const useSetTemporaryOverride = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      type,
      id,
      overrideHours,
      startDate,
      endDate,
    }: {
      type: 'business' | 'life_area';
      id: string;
      overrideHours: number;
      startDate: Date;
      endDate: Date;
    }) => {
      const table = type === 'business' ? 'businesses' : 'life_areas';
      const { error } = await supabase
        .from(table)
        .update({
          temporary_target_override: overrideHours,
          override_start_date: format(startDate, 'yyyy-MM-dd'),
          override_end_date: format(endDate, 'yyyy-MM-dd'),
        })
        .eq('id', id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['planned-vs-actual'] });
    },
  });
};
```

**Component Patterns**
```typescript
// src/components/planning/PlannedVsActualDashboard.tsx
import { useP lannedVsActual } from '@/hooks/useTimePlanning';
import { startOfWeek } from 'date-fns';

export const PlannedVsActualDashboard: React.FC = () => {
  const weekStart = startOfWeek(new Date(), { weekStartsOn: 1 });
  const { data, isLoading } = usePlannedVsActual(weekStart);

  if (isLoading) return <div>Loading...</div>;

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'on_track': return 'text-green-600';
      case 'at_risk': return 'text-yellow-600';
      case 'behind': return 'text-red-600';
      default: return 'text-gray-400';
    }
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-lg font-semibold mb-4">Planned vs. Actual This Week</h3>
      <div className="space-y-4">
        {data?.map(item => (
          <div key={item.id} className="border-b pb-4 last:border-0">
            <div className="flex justify-between items-center mb-2">
              <span className="font-medium">{item.name}</span>
              <span className={`text-sm ${getStatusColor(item.status)}`}>
                {item.percentage}% of target
              </span>
            </div>
            <div className="flex gap-2">
              {/* Target bar (light) */}
              <div className="flex-1 bg-gray-200 rounded-full h-6 relative">
                <div className="absolute inset-0 flex items-center justify-center text-xs text-gray-600">
                  Target: {item.target_hours}h
                </div>
              </div>
              {/* Actual bar (solid) */}
              <div
                className={`flex-1 rounded-full h-6 relative ${
                  item.status === 'on_track' ? 'bg-green-500'
                  : item.status === 'at_risk' ? 'bg-yellow-500'
                  : 'bg-red-500'
                }`}
                style={{ opacity: 0.9 }}
              >
                <div className="absolute inset-0 flex items-center justify-center text-xs text-white font-semibold">
                  Actual: {item.actual_hours.toFixed(1)}h
                </div>
              </div>
            </div>
            <div className="text-sm text-gray-600 mt-1">
              Delta: {item.actual_hours >= item.target_hours ? '+' : ''}
              {(item.actual_hours - item.target_hours).toFixed(1)}h
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

**File Locations:**
- Update: supabase-tasks-hub-schema.sql (add columns to businesses, life_areas, create user_settings)
- Create: supabase-target-planning-functions.sql (SQL functions)
- Create: src/pages/TimeTargetsSettings.tsx
- Create: src/pages/Planning.tsx
- Create: src/hooks/useTimePlanning.ts
- Create: src/hooks/useUserSettings.ts
- Create: src/components/planning/PlannedVsActualDashboard.tsx
- Create: src/components/planning/WeeklyTimeBudget.tsx
- Create: src/components/planning/OverAllocationWarning.tsx
- Create: src/components/planning/TargetRecommendations.tsx
- Create: src/components/planning/MonthlyTargetReview.tsx
- Create: src/components/planning/TemporaryTargetOverride.tsx
- Create: src/components/planning/WeeklyForecast.tsx
- Update: src/App.tsx (add routes: /settings/time-targets, /planning)

### Testing

**Testing Requirements:** [Source: docs/prd/technical-assumptions.md]
Manual testing with systematic verification (no automated test suite per PRD)

**Time Allocation Targets & Planning Validation Workflow:**
1. **Database Schema Verification:**
   - Run ALTER TABLE to add time_target, temporary_override, and date columns
   - Create user_settings table
   - Verify SQL functions: get_effective_target, get_planned_vs_actual, detect_target_mismatches, forecast_weekly_targets
   - Test get_effective_target: Set temporary override → verify returns override value when in date range

2. **Time Targets Settings Page Testing:**
   - Navigate to /settings/time-targets
   - Verify two sections: "Business Targets" and "Life Area Targets"
   - Set Full Stack AI target: 10h per week
   - Set Health target: 5h per week
   - Verify current actual hours shown next to input: "Current: 12h this week"
   - Save targets → verify saved to database
   - Test validation: Try to enter 200h (>168) → verify error message

3. **Planned vs. Actual Dashboard Testing:**
   - Set targets: Full Stack 10h, Huge Capital 8h, Health 5h
   - Create sessions: Full Stack 12h, Huge Capital 6h, Health 3h
   - Navigate to Planning page
   - Verify PlannedVsActualDashboard shows:
     - Full Stack: 120% (green) - on track
     - Huge Capital: 75% (red) - behind
     - Health: 60% (red) - behind
   - Verify delta indicators: Full Stack +2h, Huge Capital -2h, Health -2h

4. **Weekly Time Budget Testing:**
   - Set available hours: 40h per week in settings
   - Set targets: Total 35h across all businesses/life areas
   - Verify WeeklyTimeBudget shows: "40h available, 35h allocated, 5h unallocated"
   - Verify stacked progress bar: segments for each business/life area proportional to targets
   - Test over-allocation: Set targets totaling 50h
   - Verify warning: "⚠️ Target allocation exceeds sustainable capacity (50h planned, 40h available)"

5. **Over-Allocation Warning Testing:**
   - Set targets totaling 60h (exceed 40h available)
   - Verify OverAllocationWarning appears with red alert
   - Verify message: "Target allocation exceeds sustainable capacity (60h planned, 40h available)"
   - Click "Adjust Targets" → verify navigates to Time Targets Settings page
   - Reduce targets to 38h → verify warning disappears

6. **Target Recommendations Testing:**
   - Create 4 weeks of sessions: Full Stack consistently 12h/week (target 10h)
   - Run detect_target_mismatches function
   - Verify TargetRecommendations shows: "Full Stack: Averaging 12h/week but target is 10h - Update target to 12h?"
   - Click "Update Target" → verify target updated to 12h
   - Dismiss recommendation → verify hidden for 30 days (localStorage)

7. **Monthly Target Review Testing:**
   - Simulate end of month: August 31, 2025
   - Create sessions for August: Full Stack 40h (met target 10h/week), Health 15h (missed target 20h)
   - Navigate to MonthlyTargetReview component
   - Verify table: Full Stack ✅ Met Target, Health ❌ Missed (75% adherence)
   - Verify summary: "You met targets for 3/5 businesses and 1/4 life areas this month"
   - Verify suggestion: "Increase Health target to 6h to account for seasonal goals"

8. **Temporary Target Override Testing:**
   - Click "Set Temporary Override" on Full Stack AI
   - Enter temporary target: 15h, date range: This Week (Mon-Sun)
   - Save → verify temporary_target_override = 15, override_start_date = Monday, override_end_date = Sunday
   - Verify PlannedVsActualDashboard shows badge: "Temporary: 15h this week (normal: 10h)"
   - Verify calculations use 15h as target for this week
   - Wait for override to expire (next Monday) → verify reverts to 10h target

9. **Weekly Forecast Testing:**
   - Mid-week (Thursday): Full Stack has 6h actual (target 10h)
   - Run forecast_weekly_targets function
   - Verify projected_hours: (6h / 4 days) * 7 = 10.5h
   - Verify status: "On Track" (projected >= target)
   - Test at-risk: Health has 1h actual (target 5h), projected 1.75h
   - Verify alert: "⚠️ Health at risk: 1h so far, projected 1.75h (target 5h) - schedule time this weekend"
   - Click "Schedule Catch-Up Time" → verify navigates to Daily page

10. **Integration Testing:**
    - Full workflow: Monday morning, set targets for week
    - Tuesday: Log 3h Deep Work on Full Stack AI
    - Verify Planning page updates: Full Stack 3h / 10h (30%)
    - Thursday: Check Weekly Forecast → verify projected 5.25h (on track)
    - Friday: Log additional 8h (total 11h)
    - Verify status changes to "On Track" (110%)
    - Sunday: View end-of-week summary → verify all targets met/missed correctly
    - Next Monday: View Target Recommendations → verify suggestions based on last 4 weeks

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
