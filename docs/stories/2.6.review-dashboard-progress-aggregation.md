# Story 2.6: Review Dashboard Progress Aggregation

## Status
Ready for Review

## Story
**As a** multi-business operator,
**I want** the Review page to aggregate progress across ALL areas in one unified view,
**so that** I can see my entire life ecosystem status in 1-2 clicks without navigating to individual pages.

## Acceptance Criteria
1. Review dashboard displays 7 main area cards (DAILY, BIZNESS, CONTENT, HEALTH, FINANCES, LIFE, GOLF) with progress indicators
2. Each area card shows:
   - Area name with color coding
   - Overall completion % (aggregate of all tasks/goals in that area)
   - Active items count
   - Recent activity timestamp ("Last updated 2 hours ago")
3. Business area card drills down to show 5 businesses with individual progress bars
4. Review dashboard is READ-ONLY (no editing, only viewing aggregated data)
5. Review page loads in <2 seconds despite aggregating data from all areas
6. Visual hierarchy: areas needing attention (low %, overdue items) are highlighted with red/yellow warning colors
7. Review page includes "Weekly Progress" section showing trend: completion % today vs. 7-day average
8. One-click navigation from any Review area card to detailed page for that area

## Tasks / Subtasks
- [ ] Task 1: Create useReviewProgress hook for system-wide aggregation (AC: 1, 2, 5)
  - [ ] Create src/hooks/useReviewProgress.ts hook
  - [ ] Query all tasks grouped by area: DAILY, BIZNESS, CONTENT, HEALTH, FINANCES, LIFE, GOLF
  - [ ] Calculate completion % for each area: (tasks at 100%) / total tasks × 100
  - [ ] Calculate active items count: tasks with progress_percentage < 100
  - [ ] Query most recent task update per area: MAX(updated_at)
  - [ ] Format timestamps with date-fns: formatDistanceToNow(lastUpdate)
  - [ ] Optimize query with single Supabase call using aggregation functions
  - [ ] Return AreaProgress[] where each has: { area, progress, activeCount, lastUpdate, needsAttention }
  - [ ] Use React Query with staleTime: 60000 (1 minute cache for performance)
- [ ] Task 2: Build ReviewAreaCard component (AC: 2, 6, 8)
  - [ ] Create src/components/review/ReviewAreaCard.tsx component
  - [ ] Display area name with icon and color coding
  - [ ] Show large ProgressBar (size='lg') with completion %
  - [ ] Display active items count: "X active items"
  - [ ] Show last update timestamp: "Last updated 2 hours ago"
  - [ ] Highlight areas needing attention: progress <33% or overdue items present
  - [ ] Use warning colors: red for <20%, yellow for 20-40%, normal for >40%
  - [ ] Make entire card clickable linking to area's detail page
  - [ ] Add hover effect: border glow and scale-up animation
  - [ ] Use Lucide icons: Calendar (DAILY), Briefcase (BIZNESS), Video (CONTENT), Heart (HEALTH), DollarSign (FINANCES), Home (LIFE), Flag (GOLF)
- [ ] Task 3: Create Business drill-down in BIZNESS area card (AC: 3)
  - [ ] Update ReviewAreaCard to support expandable drill-down for BIZNESS
  - [ ] Add ChevronDown icon indicating expandable state
  - [ ] On click/expand, show 5 businesses: Full Stack AI, Service SaaS, Huge Capital, S4, 808
  - [ ] Display each business with mini ProgressBar (size='sm') and completion %
  - [ ] Use business-specific colors from theme.css
  - [ ] Show active project count per business
  - [ ] Link each business to its Business Dashboard page
  - [ ] Add "View All Businesses" link to Business Comparison page (from Story 2.4)
- [ ] Task 4: Build Review Dashboard page layout (AC: 1, 4)
  - [ ] Create src/components/review/ReviewDashboard.tsx page component
  - [ ] Add route to App.tsx for /review path
  - [ ] Display 7 area cards in responsive grid layout (2-3 columns on desktop)
  - [ ] Call useReviewProgress() to fetch all area data
  - [ ] Render ReviewAreaCard for each area
  - [ ] Add page header: "System Review" with current date
  - [ ] Ensure READ-ONLY: no edit buttons, no task creation, only viewing
  - [ ] Add prominent "Last synced: X seconds ago" indicator
  - [ ] Include refresh button to manually refetch data
- [ ] Task 5: Optimize data loading for <2 second load time (AC: 5)
  - [ ] Use single aggregated Supabase query instead of 7 separate queries
  - [ ] Implement query with COUNT, AVG, and GROUP BY for efficiency
  - [ ] Example SQL optimization:
    ```sql
    SELECT
      area,
      COUNT(*) as total_tasks,
      COUNT(*) FILTER (WHERE progress_percentage = 100) as completed_tasks,
      AVG(progress_percentage) as avg_progress,
      MAX(updated_at) as last_update
    FROM tasks
    GROUP BY area
    ```
  - [ ] Use React Query prefetching: prefetch on app load or sidebar hover
  - [ ] Enable React Query cache persistence (persist to localStorage)
  - [ ] Measure page load time with Performance API: performance.mark() / performance.measure()
  - [ ] Add loading skeleton for instant perceived performance
- [ ] Task 6: Implement visual hierarchy for areas needing attention (AC: 6)
  - [ ] Create src/utils/reviewPriority.ts utility
  - [ ] Calculate priority score per area based on:
    - Low progress (<33%): high priority
    - Overdue items present: high priority
    - No recent activity (>7 days): medium priority
    - Low progress but recent activity: medium priority
  - [ ] Sort areas by priority: highest priority first
  - [ ] Apply visual indicators:
    - High priority: red border, AlertTriangle icon, "Needs Attention" badge
    - Medium priority: yellow border, AlertCircle icon
    - Normal: default gray border
  - [ ] Use different card sizes: larger cards for high-priority areas
- [ ] Task 7: Build Weekly Progress trend section (AC: 7)
  - [ ] Create src/components/review/WeeklyProgressTrend.tsx component
  - [ ] Query tasks for last 7 days, calculate daily completion %
  - [ ] Calculate 7-day average completion %
  - [ ] Compare today's completion % vs. 7-day average
  - [ ] Display trend: "↑ 5% above average" or "↓ 3% below average"
  - [ ] Show mini line chart visualizing 7-day trend (use simple SVG or canvas)
  - [ ] Use green for above average, red for below average
  - [ ] Include weekly task completion count: "Completed 45 tasks this week"
  - [ ] Add weekly Deep Work hours: "Logged 28.5 hours this week"
- [ ] Task 8: Add one-click navigation from area cards (AC: 8)
  - [ ] Make ReviewAreaCard clickable with onClick handler
  - [ ] Navigate to area-specific page:
    - DAILY → /daily
    - BIZNESS → /business/compare (comparison view)
    - CONTENT → /content (future page, stub for now)
    - HEALTH → /health (future page, stub for now)
    - FINANCES → /finances (future page, stub for now)
    - LIFE → /life (future page, stub for now)
    - GOLF → /golf (future page, stub for now)
  - [ ] Use React Router's useNavigate hook
  - [ ] Add visual affordance: "View Details →" text in bottom-right of card
  - [ ] Show cursor pointer on hover
  - [ ] Add keyboard accessibility: Enter key to navigate

## Dev Notes

### Previous Story Insights
**From Story 2.1:** [Source: docs/stories/2.1.task-level-progress-calculation.md]
- progress_percentage field on tasks table
- Real-time sync established

**From Story 2.2:** [Source: docs/stories/2.2.phase-level-progress-calculation.md]
- ProgressBar component with size variants and color gradients
- Progress calculation patterns

**From Story 2.3:** [Source: docs/stories/2.3.project-level-progress-visualization.md]
- Aggregation and rollup calculation patterns
- Stalled detection logic

**From Story 2.4:** [Source: docs/stories/2.4.business-area-progress-dashboard.md]
- useBusinessProgress hook for business-level aggregation
- Business Comparison view pattern
- Multi-level progress calculation

**From Story 2.5:** [Source: docs/stories/2.5.daily-goals-progress-tracking.md]
- Daily progress calculation
- Weekly trend tracking concepts
- Deep Work integration

**From Story 1.1:** [Source: docs/stories/1.1.tasks-hub-page-structure.md]
- Tasks table schema with area categorization
- React Query patterns for data fetching

**Key Technical Decisions:**
- Review page is READ-ONLY aggregation view (no CRUD operations)
- Single optimized query for all 7 areas to meet <2 second load requirement
- Data cached for 1 minute (staleTime: 60000) to reduce database load
- Areas sorted by priority (needs attention first) not alphabetically
- Business drill-down only for BIZNESS area (other areas show flat progress)
- Weekly trend based on 7-day rolling average for stability

### Architecture Context

**Tech Stack:** [Source: docs/ui-architecture/2-frontend-tech-stack.md]
- React 19.1.1 + TypeScript 5.9.3
- TanStack Query 5.90.2 with cache persistence
- React Router 6.x for navigation
- date-fns 4.1.0 for date formatting
- Lucide React 0.544.0 for area icons

**Review Progress Aggregation Pattern:**
```typescript
// src/hooks/useReviewProgress.ts
import { useQuery } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase';
import { formatDistanceToNow } from 'date-fns';

export type AreaType = 'DAILY' | 'BIZNESS' | 'CONTENT' | 'HEALTH' | 'FINANCES' | 'LIFE' | 'GOLF';

interface AreaProgress {
  area: AreaType;
  progress: number;
  activeCount: number;
  totalCount: number;
  completedCount: number;
  lastUpdate: Date | null;
  lastUpdateFormatted: string;
  needsAttention: boolean;
  overdueCount: number;
}

export const useReviewProgress = () => {
  return useQuery({
    queryKey: ['review', 'progress'],
    queryFn: async () => {
      // Optimized aggregation query
      const { data: taskStats, error } = await supabase
        .rpc('get_area_progress_stats'); // Custom database function for performance

      if (error) {
        // Fallback to client-side aggregation if RPC not available
        const { data: allTasks, error: tasksError } = await supabase
          .from('tasks')
          .select('area, progress_percentage, updated_at, due_date');

        if (tasksError) throw tasksError;

        // Group by area and calculate stats
        const areaStats = (allTasks || []).reduce((acc, task) => {
          if (!acc[task.area]) {
            acc[task.area] = {
              total: 0,
              completed: 0,
              active: 0,
              overdue: 0,
              lastUpdate: null as Date | null,
            };
          }

          acc[task.area].total++;
          if (task.progress_percentage === 100) acc[task.area].completed++;
          if (task.progress_percentage < 100) acc[task.area].active++;

          const isOverdue = task.due_date && new Date(task.due_date) < new Date() && task.progress_percentage < 100;
          if (isOverdue) acc[task.area].overdue++;

          const taskUpdate = new Date(task.updated_at);
          if (!acc[task.area].lastUpdate || taskUpdate > acc[task.area].lastUpdate) {
            acc[task.area].lastUpdate = taskUpdate;
          }

          return acc;
        }, {} as Record<string, any>);

        return Object.entries(areaStats).map(([area, stats]) => ({
          area: area as AreaType,
          progress: stats.total > 0 ? (stats.completed / stats.total) * 100 : 0,
          activeCount: stats.active,
          totalCount: stats.total,
          completedCount: stats.completed,
          lastUpdate: stats.lastUpdate,
          lastUpdateFormatted: stats.lastUpdate ? formatDistanceToNow(stats.lastUpdate, { addSuffix: true }) : 'Never',
          needsAttention: stats.total > 0 && ((stats.completed / stats.total) < 0.33 || stats.overdue > 0),
          overdueCount: stats.overdue,
        })) as AreaProgress[];
      }

      // Map RPC results to AreaProgress
      return (taskStats || []).map((stat: any) => ({
        area: stat.area as AreaType,
        progress: stat.avg_progress || 0,
        activeCount: stat.active_count || 0,
        totalCount: stat.total_count || 0,
        completedCount: stat.completed_count || 0,
        lastUpdate: stat.last_update ? new Date(stat.last_update) : null,
        lastUpdateFormatted: stat.last_update ? formatDistanceToNow(new Date(stat.last_update), { addSuffix: true }) : 'Never',
        needsAttention: stat.needs_attention || false,
        overdueCount: stat.overdue_count || 0,
      })) as AreaProgress[];
    },
    staleTime: 60000, // 1 minute cache
    gcTime: 300000, // 5 minute garbage collection
  });
};
```

**Database RPC Function (Optional Optimization):**
```sql
-- Create optimized aggregation function in Supabase
CREATE OR REPLACE FUNCTION get_area_progress_stats()
RETURNS TABLE (
  area TEXT,
  total_count BIGINT,
  completed_count BIGINT,
  active_count BIGINT,
  overdue_count BIGINT,
  avg_progress NUMERIC,
  last_update TIMESTAMP,
  needs_attention BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    t.area::TEXT,
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE t.progress_percentage = 100) as completed_count,
    COUNT(*) FILTER (WHERE t.progress_percentage < 100) as active_count,
    COUNT(*) FILTER (WHERE t.due_date < NOW() AND t.progress_percentage < 100) as overdue_count,
    AVG(t.progress_percentage) as avg_progress,
    MAX(t.updated_at) as last_update,
    (AVG(t.progress_percentage) < 33 OR COUNT(*) FILTER (WHERE t.due_date < NOW() AND t.progress_percentage < 100) > 0) as needs_attention
  FROM tasks t
  WHERE t.user_id = auth.uid()
  GROUP BY t.area;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**ReviewAreaCard Component:**
```typescript
// src/components/review/ReviewAreaCard.tsx
import { FC } from 'react';
import { useNavigate } from 'react-router-dom';
import { LucideIcon, AlertTriangle, ChevronRight } from 'lucide-react';
import { ProgressBar } from '@/components/shared/ProgressBar';
import type { AreaProgress } from '@/hooks/useReviewProgress';

interface ReviewAreaCardProps {
  areaProgress: AreaProgress;
  icon: LucideIcon;
  color: string;
  route: string;
  expandable?: boolean;
}

export const ReviewAreaCard: FC<ReviewAreaCardProps> = ({
  areaProgress,
  icon: Icon,
  color,
  route,
  expandable = false,
}) => {
  const navigate = useNavigate();

  const borderColor = areaProgress.needsAttention
    ? areaProgress.progress < 20
      ? 'border-red-500'
      : 'border-yellow-500'
    : 'border-gray-700';

  return (
    <div
      className={`bg-gray-800 rounded-lg p-6 border-2 ${borderColor} hover:border-${color}-500 transition-all cursor-pointer transform hover:scale-105`}
      onClick={() => navigate(route)}
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <Icon className={`text-${color}-500`} size={28} />
          <h3 className="text-xl font-bold text-white">{areaProgress.area}</h3>
        </div>
        {areaProgress.needsAttention && (
          <AlertTriangle className="text-orange-500" size={24} />
        )}
      </div>

      {/* Progress */}
      <div className="mb-4">
        <div className="flex items-center justify-between mb-2">
          <span className="text-2xl font-bold text-white">{areaProgress.progress.toFixed(1)}%</span>
          <span className="text-sm text-gray-400">{areaProgress.completedCount} / {areaProgress.totalCount} complete</span>
        </div>
        <ProgressBar progress={areaProgress.progress} size="lg" showLabel={false} />
      </div>

      {/* Stats */}
      <div className="flex items-center justify-between text-sm">
        <span className="text-gray-400">{areaProgress.activeCount} active items</span>
        <span className="text-gray-500">{areaProgress.lastUpdateFormatted}</span>
      </div>

      {/* Navigation hint */}
      <div className="mt-4 flex items-center justify-end text-sm text-gray-400">
        <span>View Details</span>
        <ChevronRight size={16} className="ml-1" />
      </div>
    </div>
  );
};
```

**Area Configuration:**
```typescript
// src/config/reviewAreas.ts
import { Calendar, Briefcase, Video, Heart, DollarSign, Home, Flag } from 'lucide-react';
import type { AreaType } from '@/hooks/useReviewProgress';

export const REVIEW_AREAS = [
  { area: 'DAILY' as AreaType, icon: Calendar, color: 'blue', route: '/daily' },
  { area: 'BIZNESS' as AreaType, icon: Briefcase, color: 'purple', route: '/business/compare', expandable: true },
  { area: 'CONTENT' as AreaType, icon: Video, color: 'red', route: '/content' },
  { area: 'HEALTH' as AreaType, icon: Heart, color: 'green', route: '/health' },
  { area: 'FINANCES' as AreaType, icon: DollarSign, color: 'yellow', route: '/finances' },
  { area: 'LIFE' as AreaType, icon: Home, color: 'pink', route: '/life' },
  { area: 'GOLF' as AreaType, icon: Flag, color: 'orange', route: '/golf' },
];
```

**File Locations:**
- Create: src/hooks/useReviewProgress.ts
- Create: src/components/review/ReviewDashboard.tsx
- Create: src/components/review/ReviewAreaCard.tsx
- Create: src/components/review/WeeklyProgressTrend.tsx
- Create: src/config/reviewAreas.ts
- Create: src/utils/reviewPriority.ts
- Create: get_area_progress_stats.sql (optional database RPC function)
- Update: src/App.tsx (add /review route)
- Reuse: src/components/shared/ProgressBar.tsx (from Story 2.2)

### Testing

**Testing Requirements:**
1. Verify all 8 acceptance criteria
2. Test aggregation: create tasks in 3 areas → verify each area shows correct progress %
3. Test active count: create 10 tasks (6 complete, 4 active) per area → verify active counts
4. Test last update timestamp: update task → verify "Last updated X ago" updates
5. Test Business drill-down: expand BIZNESS card → verify shows 5 businesses with progress
6. Test READ-ONLY: verify no edit buttons or task creation forms present
7. Test load time: measure with Performance API → verify loads in <2 seconds
8. Test visual hierarchy: create area with <20% progress → verify red border and "Needs Attention" badge
9. Test weekly trend: complete tasks over 7 days → verify trend calculation and visualization
10. Test navigation: click each area card → verify navigates to correct page
11. Test cache: load page, wait 30 seconds, load again → verify uses cached data (no loading spinner)
12. Test priority sorting: verify areas needing attention appear first in grid

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-07 | v1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes List
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent_
